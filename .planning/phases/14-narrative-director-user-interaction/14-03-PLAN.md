---
phase: 14-narrative-director-user-interaction
plan: 03
type: execute
wave: 3
depends_on: ["14-02"]
files_modified:
  - Assets/AyaLiveStream/NarrativeDirector.cs
autonomous: true

must_haves:
  truths:
    - "Aya queue scenes execute sequentially: AyaDialogue sends context to Gemini, AyaChecksChat gathers unresponded messages and sends summary, AyaAction logs placeholder"
    - "Chat queue scenes (ChatBurst) run in parallel with Aya queue -- chat does not block Aya"
    - "AyaChecksChat prioritizes user messages over bot messages when building context for Aya"
    - "Conditional scene transitions fire on TimedOut (wait maxDuration), QuestionsAnswered (count check), and Always (immediate)"
    - "Scene execution waits for Aya's turn to complete before advancing to next scene"
  artifacts:
    - path: "Assets/AyaLiveStream/NarrativeDirector.cs"
      provides: "Scene execution methods for all 5 scene types, conditional transition logic, Aya queue runner"
      contains: "ExecuteScene"
  key_links:
    - from: "NarrativeDirector.ExecuteAyaDialogue"
      to: "PersonaSession.SendText"
      via: "dialogue alternative selection and send"
      pattern: "_session\\.SendText.*dialogue"
    - from: "NarrativeDirector.ExecuteAyaChecksChat"
      to: "ChatBotManager.GetUnrespondedMessages"
      via: "gathering unresponded messages for Aya context"
      pattern: "GetUnrespondedMessages"
    - from: "NarrativeDirector scene loop"
      to: "PersonaSession.OnTurnComplete"
      via: "waiting for Aya to finish speaking before next scene"
      pattern: "_turnComplete"
---

<objective>
Extend NarrativeDirector with scene-type execution logic for the Aya queue (AyaDialogue, AyaChecksChat, AyaAction) and conditional transition handling (TimedOut, QuestionsAnswered, Always). The chat queue (ChatBurst scenes) runs via ChatBotManager independently.

Purpose: Scenes within each beat define the specific orchestrated moments -- when Aya speaks, when she checks chat, when actions fire. This turns the time-based beat loop from 14-02 into a structured sequence of narrative moments.

Output: Extended NarrativeDirector.cs with scene execution within each beat's time window.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-narrative-director-user-interaction/14-CONTEXT.md
@.planning/phases/14-narrative-director-user-interaction/14-RESEARCH.md
@.planning/phases/14-narrative-director-user-interaction/14-02-SUMMARY.md
@Assets/AyaLiveStream/NarrativeDirector.cs
@Assets/AyaLiveStream/ChatBotManager.cs
@Assets/AyaLiveStream/NarrativeBeatConfig.cs
@Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scene execution methods to NarrativeDirector</name>
  <files>Assets/AyaLiveStream/NarrativeDirector.cs</files>
  <action>
Read the existing NarrativeDirector.cs (from 14-02) and extend it with scene-type execution. This is an additive modification -- preserve all existing beat lifecycle, event subscriptions, and pacing logic.

**Add serialized field:**
```csharp
[SerializeField] private ChatBotManager _chatBotManager;
```

**Add private state:**
```csharp
private bool _turnComplete;
private int _questionsAnsweredCount;
```

**Add to existing event subscriptions (in StartNarrative):**
The existing `_session.OnTurnComplete += HandleTurnComplete` handler should also set `_turnComplete = true` (add this line to the existing handler, do NOT create a duplicate subscription).

**Modify RunBeatLoop to execute scenes within each beat:**

Replace the simple time-wait loop inside RunBeatLoop with a scene-execution loop that runs within the beat's time budget. The structure should be:

```csharp
// Inside the for loop, after ExecuteBeatTransition:
// Run scenes within beat's time budget
float beatStartTime = Time.time;
await ExecuteBeatScenes(beat, beatStartTime);

// Replace the simple elapsed timer with:
// After scenes complete, wait for remaining beat time (if any) or goal-met
float remaining = beat.timeBudgetSeconds - (Time.time - beatStartTime);
while (remaining > 0 && !_beatGoalMet)
{
    await Awaitable.WaitForSecondsAsync(1f, destroyCancellationToken);
    remaining = beat.timeBudgetSeconds - (Time.time - beatStartTime);
    if (!_narrativeRunning) return;
}
```

**ExecuteBeatScenes(NarrativeBeatConfig beat, float beatStartTime) (async Awaitable):**
```csharp
private async Awaitable ExecuteBeatScenes(NarrativeBeatConfig beat, float beatStartTime)
{
    if (beat.scenes == null) return;

    for (int i = 0; i < beat.scenes.Length; i++)
    {
        if (!_narrativeRunning || _beatGoalMet) return;

        // Check if beat time budget has expired
        if (Time.time - beatStartTime >= beat.timeBudgetSeconds) return;

        var scene = beat.scenes[i];
        await ExecuteScene(scene);
    }
}
```

**ExecuteScene(NarrativeSceneConfig scene) (async Awaitable):**
Route to the appropriate handler based on scene.type:
```csharp
private async Awaitable ExecuteScene(NarrativeSceneConfig scene)
{
    switch (scene.type)
    {
        case SceneType.AyaDialogue:
            await ExecuteAyaDialogue(scene);
            break;
        case SceneType.AyaChecksChat:
            await ExecuteAyaChecksChat(scene);
            break;
        case SceneType.AyaAction:
            ExecuteAyaAction(scene);
            break;
        case SceneType.ChatBurst:
            // ChatBurst runs on the chat queue (ChatBotManager) independently
            // No action needed here -- ChatBotManager burst loop handles this
            break;
        case SceneType.UserChoice:
            // UserChoice not implemented in Phase 14 per scope
            Debug.Log($"[NarrativeDirector] UserChoice scene '{scene.sceneId}' skipped (Phase 14 scope)");
            break;
    }

    // Handle conditional transitions
    if (scene.isConditional)
    {
        await WaitForCondition(scene);
    }
}
```

**ExecuteAyaDialogue(NarrativeSceneConfig scene) (async Awaitable):**
```csharp
private async Awaitable ExecuteAyaDialogue(NarrativeSceneConfig scene)
{
    if (scene.dialogueAlternatives == null || scene.dialogueAlternatives.Length == 0) return;

    // Pick a random dialogue alternative
    string dialogue = scene.dialogueAlternatives[UnityEngine.Random.Range(0, scene.dialogueAlternatives.Length)];

    // Wait for Aya to finish any current speech (never send while speaking -- Pitfall 3)
    await WaitForAyaIdle();

    // Send dialogue context to Gemini via SendText
    _session.SendText(dialogue);

    // Wait for Aya to respond and complete her turn
    _turnComplete = false;
    await WaitForTurnComplete();
}
```

**ExecuteAyaChecksChat(NarrativeSceneConfig scene) (async Awaitable):**
Per 14-RESEARCH.md pattern -- gather unresponded messages, prioritize user messages, build summary, send to Aya:
```csharp
private async Awaitable ExecuteAyaChecksChat(NarrativeSceneConfig scene)
{
    if (_chatBotManager == null) return;

    var unresponded = _chatBotManager.GetUnrespondedMessages();
    if (unresponded.Count == 0)
    {
        Debug.Log($"[NarrativeDirector] AyaChecksChat '{scene.sceneId}': no unresponded messages");
        return;
    }

    // User messages get priority over bot messages (per CONTEXT.md decision)
    var userMessages = new List<TrackedChatMessage>();
    var botMessages = new List<TrackedChatMessage>();
    foreach (var msg in unresponded)
    {
        if (msg.Message.IsFromUser) userMessages.Add(msg);
        else botMessages.Add(msg);
    }

    var toAddress = userMessages.Count > 0 ? userMessages : botMessages;
    int count = Mathf.Min(toAddress.Count, scene.maxResponsesToGenerate);

    // Build summary rather than injecting each message (Pitfall 8: context window)
    var sb = new System.Text.StringBuilder();
    sb.AppendLine("[Director: Your chat audience has been active. Here are messages to respond to:]");
    for (int i = 0; i < count; i++)
    {
        var msg = toAddress[i];
        sb.AppendLine($"- {msg.Message.BotName}: \"{msg.Message.Text}\"");
        msg.AyaHasResponded = true; // Mark as addressed
    }
    sb.AppendLine("[Respond naturally to one or more of these, then continue your current topic.]");

    // Wait for Aya to finish any current speech
    await WaitForAyaIdle();

    _session.SendText(sb.ToString());

    // Wait for Aya's response to complete
    _turnComplete = false;
    await WaitForTurnComplete();

    _questionsAnsweredCount += count;
}
```

**ExecuteAyaAction(NarrativeSceneConfig scene):**
Phase 15 placeholder -- just log:
```csharp
private void ExecuteAyaAction(NarrativeSceneConfig scene)
{
    Debug.Log($"[NarrativeDirector] AyaAction '{scene.sceneId}': {scene.actionDescription} (Phase 15 placeholder)");
}
```

**WaitForCondition(NarrativeSceneConfig scene) (async Awaitable):**
```csharp
private async Awaitable WaitForCondition(NarrativeSceneConfig scene)
{
    switch (scene.conditionType)
    {
        case ConditionType.Always:
            // Immediate -- no wait
            break;

        case ConditionType.TimedOut:
            float elapsed = 0f;
            while (elapsed < scene.maxDuration && !_beatGoalMet)
            {
                await Awaitable.WaitForSecondsAsync(1f, destroyCancellationToken);
                elapsed += 1f;
            }
            break;

        case ConditionType.QuestionsAnswered:
            while (_questionsAnsweredCount < scene.requiredValue && !_beatGoalMet)
            {
                await Awaitable.WaitForSecondsAsync(0.5f, destroyCancellationToken);
            }
            break;
    }
}
```

**Helper methods:**
```csharp
private async Awaitable WaitForAyaIdle()
{
    while (_isAyaSpeaking)
    {
        await Awaitable.WaitForSecondsAsync(0.1f, destroyCancellationToken);
    }
}

private async Awaitable WaitForTurnComplete()
{
    while (!_turnComplete)
    {
        await Awaitable.WaitForSecondsAsync(0.1f, destroyCancellationToken);
    }
}
```

**Reset _questionsAnsweredCount at beat start:**
In the RunBeatLoop, at the beginning of each beat iteration (before scene execution), add:
```csharp
_questionsAnsweredCount = 0;
```

All async methods MUST use `destroyCancellationToken` and be wrapped in try/catch OperationCanceledException at the top level.

IMPORTANT: Use `System.Text.StringBuilder` (add `using System.Text;` if not already imported). Use `System.Collections.Generic.List<TrackedChatMessage>` for the user/bot message lists. Do NOT use LINQ `.Where()` to avoid unnecessary LINQ allocation in a hot path -- use a foreach loop instead.
  </action>
  <verify>
NarrativeDirector.cs compiles. Verify: has ExecuteScene method with switch on SceneType, ExecuteAyaDialogue sends SendText with random alternative, ExecuteAyaChecksChat uses GetUnrespondedMessages with user-priority, WaitForCondition handles all 3 ConditionTypes, WaitForAyaIdle guards all SendText calls.
  </verify>
  <done>NarrativeDirector executes Aya queue scenes sequentially within each beat (AyaDialogue -> AyaChecksChat -> AyaAction) with conditional transitions. Chat queue runs independently via ChatBotManager. Scene execution respects beat time budget and goal-met early exit.</done>
</task>

<task type="auto">
  <name>Task 2: Verify scene execution integrates correctly with beat lifecycle</name>
  <files>Assets/AyaLiveStream/NarrativeDirector.cs</files>
  <action>
Review the complete NarrativeDirector.cs after Task 1 modifications and verify these integration points:

1. **Beat lifecycle + scenes**: RunBeatLoop calls ExecuteBeatScenes which iterates through beat.scenes. If beat time expires mid-scene, the scene execution checks `Time.time - beatStartTime >= beat.timeBudgetSeconds` and returns early.

2. **Turn tracking**: The existing `HandleTurnComplete` (from 14-02) sets `_turnComplete = true` AND handles `_pendingBeatTransition`. Both behaviors must coexist. Verify the handler does both:
```csharp
private void HandleTurnComplete()
{
    _turnComplete = true;
    if (_pendingBeatTransition != null)
    {
        ExecuteBeatTransition(_pendingBeatTransition);
    }
}
```

3. **Event safety**: All SendText calls are preceded by WaitForAyaIdle(). Verify no code path sends SendText without this guard.

4. **Cancellation**: All `while` loops use `destroyCancellationToken` via their parent `await` calls. No infinite loops without cancellation.

5. **using directives**: Ensure `using System.Text;`, `using System.Collections.Generic;` are present. The file should also have `using System;`, `using UnityEngine;`, `using AIEmbodiment;`.

If any issues found, fix them in this task. If the code is correct, this task is a no-op verification pass.
  </action>
  <verify>
NarrativeDirector.cs compiles. Read through the complete file and confirm: HandleTurnComplete sets _turnComplete AND handles pending transitions, all SendText calls are guarded by WaitForAyaIdle, no while loops lack cancellation paths, all using directives are present.
  </verify>
  <done>NarrativeDirector scene execution is fully integrated with the beat lifecycle from 14-02. Turn tracking, event safety, and cancellation are correct.</done>
</task>

</tasks>

<verification>
1. AyaDialogue scenes send dialogue context via SendText and wait for Aya's turn to complete
2. AyaChecksChat scenes gather unresponded messages with user-priority and send summary via SendText
3. AyaAction scenes log placeholder text (Phase 15)
4. ChatBurst scenes are no-ops in NarrativeDirector (ChatBotManager handles chat independently)
5. Conditional transitions work: TimedOut waits N seconds, QuestionsAnswered counts responses, Always proceeds immediately
6. Scene execution respects beat time budget -- exits early if budget expired
7. All SendText calls guarded by WaitForAyaIdle (Pitfall 3 prevention)
8. _questionsAnsweredCount resets at each beat start
</verification>

<success_criteria>
- Aya queue scenes execute sequentially within each beat's time window
- Chat queue runs in parallel (ChatBotManager burst loop unchanged from 14-02)
- AyaChecksChat correctly prioritizes user messages over bot messages
- Conditional scene transitions advance the narrative from one scene to the next
- Scene execution integrates cleanly with beat lifecycle (no duplicate subscriptions, no event conflicts)
</success_criteria>

<output>
After completion, create `.planning/phases/14-narrative-director-user-interaction/14-03-SUMMARY.md`
</output>
