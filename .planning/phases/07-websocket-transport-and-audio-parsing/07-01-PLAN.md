---
phase: 07-websocket-transport-and-audio-parsing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/GeminiEvent.cs
  - Packages/com.google.ai-embodiment/Runtime/GeminiLiveConfig.cs
  - Packages/com.google.ai-embodiment/Runtime/GeminiLiveClient.cs
  - Packages/com.google.ai-embodiment/package.json
autonomous: true

must_haves:
  truths:
    - "GeminiLiveClient connects to Gemini Live WebSocket endpoint and receives setupComplete acknowledgment"
    - "SendAudio transmits base64-encoded 16kHz PCM audio via realtimeInput.audio (non-deprecated format)"
    - "SendText transmits user text via clientContent with turnComplete:true"
    - "Disconnect performs clean WebSocket close handshake and the client transitions to not-connected"
    - "ProcessEvents drains ConcurrentQueue and invokes OnEvent for each dequeued event"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/GeminiEvent.cs"
      provides: "GeminiEventType enum and GeminiEvent struct"
      contains: "GeminiEventType"
    - path: "Packages/com.google.ai-embodiment/Runtime/GeminiLiveConfig.cs"
      provides: "Config POCO with ApiKey, Model, SystemInstruction, VoiceName, sample rates"
      contains: "GeminiLiveConfig"
    - path: "Packages/com.google.ai-embodiment/Runtime/GeminiLiveClient.cs"
      provides: "WebSocket client with ConnectAsync, Disconnect, SendAudio, SendText, ProcessEvents"
      exports: ["ConnectAsync", "Disconnect", "SendAudio", "SendText", "ProcessEvents", "OnEvent", "IsConnected"]
    - path: "Packages/com.google.ai-embodiment/package.json"
      provides: "Newtonsoft.Json dependency declaration"
      contains: "com.unity.nuget.newtonsoft-json"
  key_links:
    - from: "GeminiLiveClient.cs"
      to: "GeminiEvent.cs"
      via: "ConcurrentQueue<GeminiEvent> and OnEvent action"
      pattern: "ConcurrentQueue<GeminiEvent>"
    - from: "GeminiLiveClient.cs"
      to: "GeminiLiveConfig.cs"
      via: "Constructor parameter"
      pattern: "GeminiLiveConfig"
    - from: "GeminiLiveClient.ConnectAsync"
      to: "wss://generativelanguage.googleapis.com"
      via: "ClientWebSocket.ConnectAsync"
      pattern: "generativelanguage\\.googleapis\\.com"
    - from: "GeminiLiveClient.SendAudio"
      to: "Gemini Live API"
      via: "realtimeInput.audio JSON payload"
      pattern: "realtimeInput.*audio"
---

<objective>
Create the GeminiLiveClient WebSocket client with connection lifecycle, setup handshake, send methods, and event queue infrastructure.

Purpose: This is the foundation of the v0.8 WebSocket transport. It replaces Firebase AI Logic SDK's LiveSession with a direct WebSocket client that the rest of the package will consume. All outbound communication (connect, send audio, send text, disconnect) and the event queue mechanism are established here.

Output: Three new C# files (GeminiEvent.cs, GeminiLiveConfig.cs, GeminiLiveClient.cs) and updated package.json with Newtonsoft.Json dependency. The client can connect, complete the setup handshake, send audio/text, and disconnect cleanly. The receive loop (inbound parsing) is added in Plan 02.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-websocket-transport-and-audio-parsing/07-RESEARCH.md

# Reference implementation (adapt, do not copy verbatim)
@/home/cachy/workspaces/projects/persona/unity/Persona/Runtime/GeminiLiveClient.cs

# Existing codebase files for namespace/pattern reference
@Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
@Packages/com.google.ai-embodiment/Runtime/MainThreadDispatcher.cs
@Packages/com.google.ai-embodiment/Runtime/SessionState.cs
@Packages/com.google.ai-embodiment/package.json
@Packages/com.google.ai-embodiment/Runtime/com.google.ai-embodiment.asmdef
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create data types and add Newtonsoft.Json dependency</name>
  <files>
    Packages/com.google.ai-embodiment/Runtime/GeminiEvent.cs
    Packages/com.google.ai-embodiment/Runtime/GeminiLiveConfig.cs
    Packages/com.google.ai-embodiment/package.json
  </files>
  <action>
    Create GeminiEvent.cs in the AIEmbodiment namespace containing:

    1. GeminiEventType enum with values: Audio, OutputTranscription, InputTranscription, TurnComplete, Interrupted, FunctionCall, Connected, Disconnected, Error

    2. GeminiEvent struct with fields:
       - GeminiEventType Type
       - string Text (for transcription, error, disconnected events)
       - float[] AudioData (for Audio events -- 24kHz mono float[], already converted from 16-bit PCM)
       - int AudioSampleRate (always 24000 for audio events)
       - string FunctionName (for FunctionCall events, used in Phase 10)
       - string FunctionArgsJson (for FunctionCall events, used in Phase 10)

    Create GeminiLiveConfig.cs in the AIEmbodiment namespace containing:

    A plain C# class (NOT ScriptableObject, NOT MonoBehaviour) with public fields:
       - string ApiKey
       - string Model = "gemini-2.5-flash-native-audio-preview-12-2025"
       - string SystemInstruction
       - string VoiceName = "Puck"
       - int AudioInputSampleRate = 16000
       - int AudioOutputSampleRate = 24000

    Update package.json to add Newtonsoft.Json dependency:
       Add to "dependencies": "com.unity.nuget.newtonsoft-json": "3.2.1"

    IMPORTANT: Use the AIEmbodiment namespace for all files. Do NOT add XML doc comments beyond a single summary on each type. Keep files minimal -- these are data containers.
  </action>
  <verify>
    Grep for "GeminiEventType" in GeminiEvent.cs -- should find the enum with 9 values.
    Grep for "GeminiLiveConfig" in GeminiLiveConfig.cs -- should find the class.
    Grep for "newtonsoft" in package.json -- should find the dependency.
  </verify>
  <done>
    GeminiEvent.cs defines GeminiEventType enum (9 values) and GeminiEvent struct (6 fields).
    GeminiLiveConfig.cs defines a plain C# config class with ApiKey, Model, SystemInstruction, VoiceName, sample rates.
    package.json includes com.unity.nuget.newtonsoft-json dependency.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GeminiLiveClient with connection lifecycle and send methods</name>
  <files>
    Packages/com.google.ai-embodiment/Runtime/GeminiLiveClient.cs
  </files>
  <action>
    Create GeminiLiveClient.cs in the AIEmbodiment namespace. This is a pure C# class (no UnityEngine dependency) implementing IDisposable. Adapt from the reference implementation at /home/cachy/workspaces/projects/persona/unity/Persona/Runtime/GeminiLiveClient.cs, stripping all emote/animation/text-filtering logic.

    Required using statements:
    - System
    - System.Collections.Concurrent
    - System.Net.WebSockets
    - System.Text
    - System.Threading
    - System.Threading.Tasks
    - Newtonsoft.Json.Linq

    Class structure:

    1. Constants and fields:
       - BaseUrl = "wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1beta.GenerativeService.BidiGenerateContent"
       - private readonly GeminiLiveConfig _config
       - private ClientWebSocket _ws
       - private CancellationTokenSource _cts
       - private readonly ConcurrentQueue<GeminiEvent> _eventQueue
       - private volatile bool _connected
       - private volatile bool _setupComplete

    2. Public API:
       - event Action<GeminiEvent> OnEvent
       - bool IsConnected => _connected && _setupComplete
       - Constructor(GeminiLiveConfig config) -- null check, store config
       - async Task ConnectAsync() -- if already connected, return. Create CTS, create ClientWebSocket, connect to BaseUrl?key=ApiKey, set _connected=true, send setup message, fire-and-forget receive loop with _ = ReceiveLoop(_cts.Token). NOTE: ReceiveLoop will be a stub (empty async Task) -- Plan 02 fills it in.
       - void Disconnect() -- set _connected=false, _setupComplete=false, cancel CTS, attempt CloseAsync with CancellationToken.None and 2-second timeout (swallow exceptions), dispose WebSocket and CTS, enqueue Disconnected event
       - void SendAudio(byte[] pcm16Data) -- guard with IsConnected and null/empty check. Base64-encode pcm16Data. Build JSON: {"realtimeInput": {"audio": {"mimeType": "audio/pcm;rate=16000", "data": "<base64>"}}}. Fire-and-forget SendJsonAsync. IMPORTANT: Use "realtimeInput.audio" NOT the deprecated "mediaChunks" format.
       - void SendText(string message) -- guard with IsConnected and null/empty check. Build JSON: {"clientContent": {"turns": [{"role": "user", "parts": [{"text": message}]}], "turnComplete": true}}. Fire-and-forget SendJsonAsync.
       - void ProcessEvents() -- drain _eventQueue, invoke OnEvent for each
       - void Dispose() -- call Disconnect()

    3. Private methods:
       - async Task SendSetupMessage() -- Build the setup JSON per the research document:
         * setup.model = "models/" + _config.Model (CRITICAL: include "models/" prefix)
         * setup.generationConfig.responseModalities = ["AUDIO"] (AUD-01)
         * setup.generationConfig.speechConfig.voiceConfig.prebuiltVoiceConfig.voiceName = _config.VoiceName ?? "Puck"
         * setup.outputAudioTranscription = {} (enables AUD-04)
         * setup.inputAudioTranscription = {} (enables AUD-03)
         * If _config.SystemInstruction is not null/empty, add systemInstruction.parts[{text: ...}]
         * Wrap in {"setup": innerObject} and send via SendJsonAsync
       - async Task SendJsonAsync(JObject payload) -- guard _ws null or not Open. UTF-8 encode payload.ToString(Formatting.None). Send as Text WebSocketMessageType, endOfMessage=true, using _cts.Token. Swallow exceptions (connection may be torn down).
       - private void Enqueue(GeminiEvent ev) -- _eventQueue.Enqueue(ev)
       - private async Task ReceiveLoop(CancellationToken ct) -- STUB for now: just an empty async task that awaits Task.CompletedTask. Plan 02 replaces this with the full implementation.

    Key differences from reference:
    - AIEmbodiment namespace (not Persona)
    - No emote/animation/textEmoteMode logic at all
    - No BuildToolsJson, GatherAnimationNames, FunctionToDeclaration, etc. (Phase 10 concern)
    - SendAudio uses "realtimeInput.audio" NOT deprecated "mediaChunks"
    - ReceiveLoop is a stub (Plan 02)

    IMPORTANT: Do NOT reference UnityEngine anywhere. This is pure C#.
    IMPORTANT: The setup message must include "models/" prefix on the model name (Pitfall 4 from research).
    IMPORTANT: Disconnect must cancel CTS FIRST, then attempt close, then dispose (Pitfall 5 from research).
  </action>
  <verify>
    Grep for "ConnectAsync" in GeminiLiveClient.cs -- should find the method.
    Grep for "SendAudio" in GeminiLiveClient.cs -- should find the method with "realtimeInput" JSON.
    Grep for "realtimeInput.*audio" in GeminiLiveClient.cs -- confirms non-deprecated format.
    Grep for "mediaChunks" in GeminiLiveClient.cs -- should find ZERO matches (deprecated format not used).
    Grep for "models/" in GeminiLiveClient.cs -- should find the model prefix.
    Grep for "ProcessEvents" in GeminiLiveClient.cs -- should find the queue drain method.
  </verify>
  <done>
    GeminiLiveClient.cs exists with: ConnectAsync (WebSocket connect + setup handshake), Disconnect (clean close with CTS cancellation), SendAudio (non-deprecated realtimeInput.audio format), SendText (clientContent), ProcessEvents (ConcurrentQueue drain), OnEvent (public event), IsConnected (volatile bool). ReceiveLoop is a stub awaiting Plan 02. No UnityEngine references. No emote/animation logic.
  </done>
</task>

</tasks>

<verification>
1. GeminiEvent.cs, GeminiLiveConfig.cs, GeminiLiveClient.cs exist in Packages/com.google.ai-embodiment/Runtime/
2. All three files use namespace AIEmbodiment
3. package.json includes "com.unity.nuget.newtonsoft-json": "3.2.1" in dependencies
4. GeminiLiveClient has no "using UnityEngine" statement
5. GeminiLiveClient uses "realtimeInput.audio" NOT "mediaChunks" in SendAudio
6. GeminiLiveClient setup message includes "models/" prefix on model name
7. GeminiLiveClient.IsConnected requires both _connected AND _setupComplete
8. Disconnect cancels CTS before attempting WebSocket close
</verification>

<success_criteria>
Three new C# files compile (in the AIEmbodiment namespace) and package.json has Newtonsoft.Json dependency. GeminiLiveClient can construct, has ConnectAsync/Disconnect/SendAudio/SendText/ProcessEvents methods. The receive loop is a stub ready for Plan 02 to fill in.
</success_criteria>

<output>
After completion, create `.planning/phases/07-websocket-transport-and-audio-parsing/07-01-SUMMARY.md`
</output>
