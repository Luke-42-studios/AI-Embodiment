---
phase: 01-foundation-and-core-session
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - Packages/com.luke42studios.ai-embodiment/Runtime/PersonaSession.cs
autonomous: true

must_haves:
  truths:
    - "Developer can add PersonaSession to a GameObject, assign a PersonaConfig, and call Connect() to establish a Gemini Live session"
    - "PersonaSession sustains multi-turn text conversation (receives responses after TurnComplete without dying)"
    - "PersonaSession fires state change events (Connecting, Connected, Error, Disconnected) that developer code can subscribe to"
    - "PersonaSession.Disconnect() cleanly closes the session without leaked WebSocket connections"
    - "OnDestroy cancels the session and cleans up resources even during scene transitions"
    - "Developer can send text via SendText() and receive responses via OnTextReceived event"
  artifacts:
    - path: "Packages/com.luke42studios.ai-embodiment/Runtime/PersonaSession.cs"
      provides: "MonoBehaviour managing Gemini Live session lifecycle with multi-turn receive loop"
      min_lines: 100
      exports: ["PersonaSession"]
      contains: "class PersonaSession"
  key_links:
    - from: "Packages/com.luke42studios.ai-embodiment/Runtime/PersonaSession.cs"
      to: "Packages/com.luke42studios.ai-embodiment/Runtime/PersonaConfig.cs"
      via: "serialized field reference assigned in Inspector"
      pattern: "SerializeField.*PersonaConfig"
    - from: "Packages/com.luke42studios.ai-embodiment/Runtime/PersonaSession.cs"
      to: "Packages/com.luke42studios.ai-embodiment/Runtime/SystemInstructionBuilder.cs"
      via: "SystemInstructionBuilder.Build(_config) call in Connect()"
      pattern: "SystemInstructionBuilder\\.Build"
    - from: "Packages/com.luke42studios.ai-embodiment/Runtime/PersonaSession.cs"
      to: "Packages/com.luke42studios.ai-embodiment/Runtime/MainThreadDispatcher.cs"
      via: "MainThreadDispatcher.Enqueue() in receive loop and error handlers"
      pattern: "MainThreadDispatcher\\.Enqueue"
    - from: "Packages/com.luke42studios.ai-embodiment/Runtime/PersonaSession.cs"
      to: "Firebase.AI.LiveSession"
      via: "ConnectAsync returns LiveSession, ReceiveAsync for message loop, SendAsync for text"
      pattern: "ConnectAsync|ReceiveAsync|SendAsync"
    - from: "Packages/com.luke42studios.ai-embodiment/Runtime/PersonaSession.cs"
      to: "Packages/com.luke42studios.ai-embodiment/Runtime/SessionState.cs"
      via: "State property and OnStateChanged event"
      pattern: "SessionState"
---

<objective>
Create PersonaSession -- the core MonoBehaviour that manages the Gemini Live session lifecycle, including connection, multi-turn receive loop, state events, text messaging, and clean disconnection.

Purpose: PersonaSession is the primary runtime component that developers interact with. It ties together everything from Plans 01-01 and 01-02: MainThreadDispatcher for threading safety, PersonaConfig for configuration, SystemInstructionBuilder for system instructions, and the Firebase AI SDK for the actual Gemini Live connection. This is the most complex component in Phase 1 and the foundation that all future phases build upon.

Output: A fully functional PersonaSession MonoBehaviour that sustains multi-turn text conversations over Gemini Live.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-core-session/01-RESEARCH.md
@.planning/phases/01-foundation-and-core-session/01-01-SUMMARY.md
@.planning/phases/01-foundation-and-core-session/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: PersonaSession MonoBehaviour -- connection, state events, and SendText</name>
  <files>
    Packages/com.luke42studios.ai-embodiment/Runtime/PersonaSession.cs
  </files>
  <action>
    **PersonaSession.cs** -- Create in `Packages/com.luke42studios.ai-embodiment/Runtime/`:

    Namespace: `AIEmbodiment`

    A public MonoBehaviour class with:

    **Serialized fields:**
    - `[SerializeField] private PersonaConfig _config;` -- Assigned in Inspector

    **Public properties:**
    - `public SessionState State { get; private set; } = SessionState.Disconnected;`
    - `public PersonaConfig Config => _config;` -- Read-only access to current config

    **Public events (C# delegates, NOT UnityEvents):**
    - `public event Action<SessionState> OnStateChanged;` -- Fires on every state transition
    - `public event Action<string> OnTextReceived;` -- Fires when text chunk arrives from AI
    - `public event Action OnTurnComplete;` -- Fires when AI completes a response turn
    - `public event Action<string> OnInputTranscription;` -- Fires with user speech transcript (Phase 2 will populate)
    - `public event Action<string> OnOutputTranscription;` -- Fires with AI speech transcript
    - `public event Action OnInterrupted;` -- Fires when user interrupts AI
    - `public event Action<Exception> OnError;` -- Fires on errors

    **Private fields:**
    - `private CancellationTokenSource _sessionCts;`
    - `private LiveSession _liveSession;` -- From Firebase.AI

    **Private helper -- SetState:**
    ```csharp
    private void SetState(SessionState newState)
    {
        if (State == newState) return;
        State = newState;
        OnStateChanged?.Invoke(newState);
    }
    ```

    **Public method -- Connect():**
    ```csharp
    public async void Connect()
    ```
    Why `async void`: This is a MonoBehaviour entry point (called from user code or UI buttons). Wrap the ENTIRE body in try-catch. `async Task` would require callers to await, which is awkward for Unity button callbacks.

    Implementation:
    1. Guard: if State is not Disconnected, log warning and return
    2. Guard: if _config is null, log error "PersonaSession: No PersonaConfig assigned." and return
    3. SetState(SessionState.Connecting)
    4. Create `_sessionCts = new CancellationTokenSource()`
    5. Get FirebaseAI instance: `var ai = FirebaseAI.GetInstance(FirebaseAI.Backend.GoogleAI());`
    6. Build LiveGenerationConfig:
       ```csharp
       var liveConfig = new LiveGenerationConfig(
           responseModalities: new[] { ResponseModality.Audio },
           speechConfig: SpeechConfig.UsePrebuiltVoice(_config.geminiVoiceName),
           temperature: _config.temperature,
           inputAudioTranscription: new AudioTranscriptionConfig(),
           outputAudioTranscription: new AudioTranscriptionConfig()
       );
       ```
       Note: Use ResponseModality.Audio even for Phase 1 text testing. The SendAsync path with turnComplete:true sends structured content which works regardless of response modality. Transcription configs enable the input/output transcript events.
    7. Build system instruction: `var systemInstruction = SystemInstructionBuilder.Build(_config);`
    8. Get live model: `var liveModel = ai.GetLiveModel(modelName: _config.modelName, liveGenerationConfig: liveConfig, systemInstruction: systemInstruction);`
    9. Connect: `_liveSession = await liveModel.ConnectAsync(_sessionCts.Token);`
    10. SetState(SessionState.Connected)
    11. Fire and forget receive loop: `_ = ReceiveLoopAsync(_liveSession, _sessionCts.Token);`
    12. Catch block: SetState(Error), invoke OnError, Debug.LogError with the exception message

    **Public method -- SendText(string message):**
    ```csharp
    public async void SendText(string message)
    ```
    Again `async void` as a user-facing entry point with full try-catch.

    Implementation:
    1. Guard: if _liveSession is null or State is not Connected, log warning and return
    2. Guard: if message is null/empty, return
    3. Call `await _liveSession.SendAsync(content: ModelContent.Text(message), turnComplete: true, cancellationToken: _sessionCts.Token);`
    4. Catch: enqueue error to MainThreadDispatcher (SendText may be called from main thread already, but the await continuation may land on a different thread depending on the SDK)

    **Public method -- Disconnect():**
    ```csharp
    public async void Disconnect()
    ```
    Implementation:
    1. Guard: if State is Disconnected or Disconnecting, return
    2. SetState(SessionState.Disconnecting)
    3. Cancel the CancellationTokenSource: `_sessionCts?.Cancel();`
    4. If _liveSession is not null:
       - Try: `await _liveSession.CloseAsync(CancellationToken.None);` (use CancellationToken.None because we WANT the close handshake to complete even though we cancelled the session CTS)
       - Catch: swallow exception (WebSocket may already be closed -- this is expected per research Pitfall 7)
       - Dispose: `_liveSession.Dispose(); _liveSession = null;`
    5. Dispose CTS: `_sessionCts?.Dispose(); _sessionCts = null;`
    6. SetState(SessionState.Disconnected)
    7. Full try-catch around entire body, catch sets state to Disconnected

    **Unity lifecycle -- OnDestroy():**
    Synchronous cleanup as a safety net:
    ```csharp
    private void OnDestroy()
    {
        _sessionCts?.Cancel();
        _liveSession?.Dispose();
        _sessionCts?.Dispose();
        _liveSession = null;
        _sessionCts = null;
    }
    ```
    Do NOT call async Disconnect here -- OnDestroy is synchronous. The Cancel() will cause the receive loop to exit via OperationCanceledException. Dispose handles the rest. This prevents leaked WebSocket connections during scene transitions.
  </action>
  <verify>
    1. Verify file exists: `ls Packages/com.luke42studios.ai-embodiment/Runtime/PersonaSession.cs`
    2. Verify all public methods: grep for `public async void Connect`, `public async void SendText`, `public async void Disconnect`
    3. Verify all events: grep for `event Action.*OnStateChanged`, `event Action.*OnTextReceived`, `event Action.*OnTurnComplete`, `event Action.*OnError`
    4. Verify config field: grep for `SerializeField.*PersonaConfig`
    5. Verify CancellationTokenSource: grep for `CancellationTokenSource` in PersonaSession.cs
    6. Verify OnDestroy safety net: grep for `OnDestroy` in PersonaSession.cs
    7. Verify Firebase imports: grep for `using Firebase.AI` in PersonaSession.cs
    8. Verify SetState helper: grep for `SetState.*SessionState` in PersonaSession.cs
  </verify>
  <done>
    - Connect() establishes Gemini Live session via FirebaseAI.GetInstance with GoogleAI backend
    - Connect() fires Connecting -> Connected state transitions (or Error on failure)
    - SendText() sends text via LiveSession.SendAsync with turnComplete:true
    - Disconnect() cleanly closes: Cancel CTS -> await CloseAsync -> Dispose -> Disconnected state
    - OnDestroy() provides synchronous safety net for scene transitions
    - All 7 events declared (OnStateChanged, OnTextReceived, OnTurnComplete, OnInputTranscription, OnOutputTranscription, OnInterrupted, OnError)
    - Requirements covered: SESS-04 (MonoBehaviour + config assignment), SESS-05 (Connect via Firebase), SESS-08 (state events), SESS-09 (Disconnect cleanup)
  </done>
</task>

<task type="auto">
  <name>Task 2: PersonaSession receive loop -- multi-turn lifecycle and response processing</name>
  <files>
    Packages/com.luke42studios.ai-embodiment/Runtime/PersonaSession.cs
  </files>
  <action>
    Add to PersonaSession.cs (same file as Task 1 -- these are private methods that complete the class):

    **Private method -- ReceiveLoopAsync:**
    ```csharp
    private async Task ReceiveLoopAsync(LiveSession session, CancellationToken ct)
    ```

    This is the CRITICAL method that solves the "single-turn trap" (Research Pitfall 1). It runs on a background thread pool thread for the entire session duration.

    Implementation:
    1. Outer try block wrapping everything
    2. `while (!ct.IsCancellationRequested)` -- outer loop that RE-CALLS ReceiveAsync after each TurnComplete
    3. Inside: `await foreach (var response in session.ReceiveAsync(ct))` -- iterates messages within one turn
    4. For each response: call `ProcessResponse(response)` which enqueues everything to main thread
    5. After the inner foreach completes (TurnComplete received): loop back to the outer while to start receiving the next turn
    6. Catch `OperationCanceledException` -- expected during shutdown, do nothing (session is intentionally closing)
    7. Catch `Exception` -- enqueue to MainThreadDispatcher: `MainThreadDispatcher.Enqueue(() => { SetState(SessionState.Error); OnError?.Invoke(ex); });`
    8. Finally block: If the loop exits for any reason and State is still Connected, enqueue state transition to Disconnected: `MainThreadDispatcher.Enqueue(() => { if (State == SessionState.Connected) SetState(SessionState.Disconnected); });`

    Why the outer while loop: The Firebase SDK's ReceiveAsync (LiveSession.cs line 328-333) breaks the IAsyncEnumerable at each TurnComplete message. Without the outer loop, the session processes exactly ONE response turn and then silently stops receiving. This is the most important implementation detail in Phase 1.

    **Private method -- ProcessResponse:**
    ```csharp
    private void ProcessResponse(LiveSessionResponse response)
    ```

    This runs on a BACKGROUND THREAD. Every callback MUST go through MainThreadDispatcher.Enqueue. Do NOT call any Unity API (except Debug.Log) directly.

    Implementation -- check the response message type:

    1. Get text: `string text = response.Text;`
    2. If `response.Message is LiveSessionContent content`:
       - If text is not null/empty: `MainThreadDispatcher.Enqueue(() => OnTextReceived?.Invoke(text));`
       - If `content.TurnComplete`: `MainThreadDispatcher.Enqueue(() => OnTurnComplete?.Invoke());`
       - If `content.Interrupted`: `MainThreadDispatcher.Enqueue(() => OnInterrupted?.Invoke());`
       - If `content.InputTranscription.HasValue`: capture text locally, then `MainThreadDispatcher.Enqueue(() => OnInputTranscription?.Invoke(transcript));`
       - If `content.OutputTranscription.HasValue`: capture text locally, then `MainThreadDispatcher.Enqueue(() => OnOutputTranscription?.Invoke(transcript));`
    3. If `response.Message is LiveSessionToolCall`:
       - Log a debug message: "PersonaSession: Tool call received (not implemented until Phase 4)"
       - This is a placeholder -- Phase 4 will add FunctionCallHandler dispatch here

    IMPORTANT threading note: Capture ALL data from the response into local variables BEFORE passing to the Enqueue lambda. The lambda captures by reference -- if you pass `response.Text` directly in the lambda, the response object may have changed by the time the main thread executes the lambda.

    The complete PersonaSession.cs file should have these imports:
    ```csharp
    using System;
    using System.Threading;
    using System.Threading.Tasks;
    using Firebase.AI;
    using UnityEngine;
    ```
  </action>
  <verify>
    1. Verify outer while loop: grep for `while.*IsCancellationRequested` in PersonaSession.cs
    2. Verify ReceiveAsync call: grep for `ReceiveAsync` in PersonaSession.cs
    3. Verify MainThreadDispatcher.Enqueue in ProcessResponse: grep for `MainThreadDispatcher.Enqueue` in PersonaSession.cs (should appear 5+ times)
    4. Verify OperationCanceledException catch: grep for `OperationCanceledException` in PersonaSession.cs
    5. Verify LiveSessionContent handling: grep for `LiveSessionContent` in PersonaSession.cs
    6. Verify LiveSessionToolCall placeholder: grep for `LiveSessionToolCall` in PersonaSession.cs
    7. Verify TurnComplete handling: grep for `TurnComplete` in PersonaSession.cs
    8. Verify variable capture pattern: confirm text/transcript values are captured in local variables before lambda
    9. Count MainThreadDispatcher.Enqueue calls: should be at least 5 (text, turn complete, interrupted, input transcription, output transcription) plus error handlers
  </verify>
  <done>
    - ReceiveLoopAsync has outer while loop solving the single-turn trap (Research Pitfall 1)
    - ReceiveLoopAsync handles OperationCanceledException gracefully for clean shutdown
    - ReceiveLoopAsync transitions to Disconnected if loop exits unexpectedly
    - ProcessResponse dispatches ALL callbacks through MainThreadDispatcher (Research Pitfall 2 - threading safety)
    - ProcessResponse handles: text chunks, turn complete, interrupted, input transcription, output transcription, and tool call placeholder
    - All response data captured in local variables before lambda capture
    - Requirements fully covered: SESS-06 (receive loop re-calls after TurnComplete), SESS-07 (MainThreadDispatcher marshaling)
  </done>
</task>

</tasks>

<verification>
1. PersonaSession.cs compiles with all required imports (System, System.Threading, System.Threading.Tasks, Firebase.AI, UnityEngine)
2. Connect() uses GoogleAI backend, builds LiveGenerationConfig with voice config, calls ConnectAsync
3. ReceiveLoopAsync has outer while loop wrapping ReceiveAsync (multi-turn)
4. ALL callbacks from background thread go through MainThreadDispatcher.Enqueue
5. Disconnect() follows sequence: Cancel CTS -> await CloseAsync -> Dispose -> state transition
6. OnDestroy() provides synchronous cleanup safety net
7. All 7 events are invokable from ProcessResponse and error handlers
8. Text is sent via SendAsync with turnComplete:true
</verification>

<success_criteria>
- Developer can add PersonaSession to a GameObject, assign a PersonaConfig in Inspector, and call Connect()
- PersonaSession establishes a Gemini Live session and fires Connecting -> Connected state events
- Multi-turn text conversation works: send text, receive response, send again, receive again (no session death after first turn)
- State events fire correctly for all transitions (Connecting, Connected, Error, Disconnecting, Disconnected)
- Disconnect() and OnDestroy() clean up without leaked connections or threads
- All Phase 1 requirements fully covered: SESS-01 through SESS-09 and PKG-01
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-core-session/01-03-SUMMARY.md`
</output>
