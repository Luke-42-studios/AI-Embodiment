---
phase: 04-function-calling-and-conversational-goals
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/GoalPriority.cs
  - Packages/com.google.ai-embodiment/Runtime/ConversationalGoal.cs
  - Packages/com.google.ai-embodiment/Runtime/GoalManager.cs
autonomous: true

must_haves:
  truths:
    - "GoalPriority enum defines Low, Medium, High levels"
    - "ConversationalGoal stores ID, description, and mutable priority"
    - "GoalManager maintains a list of active goals and composes urgency-framed instruction text"
    - "GoalManager supports add, remove, reprioritize, and get-all operations"
    - "Composed goal instruction text includes priority-specific urgency framing"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/GoalPriority.cs"
      provides: "Priority level enum"
      contains: "enum GoalPriority"
    - path: "Packages/com.google.ai-embodiment/Runtime/ConversationalGoal.cs"
      provides: "Goal data type with ID, description, priority"
      contains: "class ConversationalGoal"
    - path: "Packages/com.google.ai-embodiment/Runtime/GoalManager.cs"
      provides: "Goal storage, lifecycle, and system instruction composition"
      contains: "class GoalManager"
  key_links:
    - from: "GoalManager.ComposeGoalInstruction"
      to: "GoalPriority"
      via: "switch on priority level to select urgency framing text"
      pattern: "HIGH PRIORITY|MEDIUM PRIORITY|LOW PRIORITY"
---

<objective>
Create the conversational goals infrastructure: GoalPriority enum, ConversationalGoal data class, and GoalManager with goal lifecycle and urgency-framed instruction composition.

Purpose: These types let developers define goals with priority levels and let the system compose goal text into the AI's system instruction. GoalManager will be wired into PersonaSession in Plan 04-03.

Output: Three new C# files in the Runtime directory.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-function-calling-and-conversational-goals/04-CONTEXT.md
@.planning/phases/04-function-calling-and-conversational-goals/04-RESEARCH.md

Source files to reference for patterns:
@Packages/com.google.ai-embodiment/Runtime/SessionState.cs
@Packages/com.google.ai-embodiment/Runtime/VoiceBackend.cs
@Packages/com.google.ai-embodiment/Runtime/SystemInstructionBuilder.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: GoalPriority enum and ConversationalGoal data class</name>
  <files>
    Packages/com.google.ai-embodiment/Runtime/GoalPriority.cs
    Packages/com.google.ai-embodiment/Runtime/ConversationalGoal.cs
  </files>
  <action>
**GoalPriority.cs:**
Create a simple enum in namespace `AIEmbodiment` following the same pattern as `VoiceBackend.cs` and `SessionState.cs`:
```csharp
public enum GoalPriority
{
    Low,
    Medium,
    High
}
```
Include XML doc summary on the enum and each member.

**ConversationalGoal.cs:**
Create a class in namespace `AIEmbodiment`:
```csharp
public class ConversationalGoal
{
    public string Id { get; }
    public string Description { get; }
    public GoalPriority Priority { get; set; }  // mutable -- CONTEXT.md says "Priority is mutable"
}
```

- Constructor: `ConversationalGoal(string id, string description, GoalPriority priority)`
- Validate that id and description are not null/empty (throw ArgumentException)
- Id is immutable (get-only), Description is immutable (get-only), Priority is mutable (get/set)
- Class, not struct -- goals are reference types managed in a list, identity matters

Include full XML doc comments on all public members following the existing codebase style.
  </action>
  <verify>Both files exist. GoalPriority has Low/Medium/High values. ConversationalGoal has Id (get), Description (get), Priority (get/set) properties and a validating constructor.</verify>
  <done>GoalPriority enum and ConversationalGoal class define the goal data model with mutable priority for runtime reprioritization.</done>
</task>

<task type="auto">
  <name>Task 2: GoalManager with lifecycle and instruction composition</name>
  <files>Packages/com.google.ai-embodiment/Runtime/GoalManager.cs</files>
  <action>
Create `GoalManager` class in namespace `AIEmbodiment`. This is a plain C# class (not MonoBehaviour), similar to PacketAssembler in being logic-only.

**Private state:**
- `List<ConversationalGoal> _goals` -- active goals list

**Public methods:**

1. `void AddGoal(ConversationalGoal goal)`
   - Adds goal to the list
   - Throws ArgumentNullException if goal is null

2. `bool RemoveGoal(string goalId)`
   - Removes goal by ID, returns true if found and removed
   - Case-sensitive ID match

3. `ConversationalGoal GetGoal(string goalId)`
   - Returns goal by ID, or null if not found (for reprioritization: `manager.GetGoal("id").Priority = GoalPriority.High`)

4. `IReadOnlyList<ConversationalGoal> GetActiveGoals()`
   - Returns read-only view of active goals

5. `bool HasGoals` (property)
   - Returns true if any goals are active

6. `string ComposeGoalInstruction()`
   - Returns empty string if no goals
   - Otherwise composes a structured text block following the Research Pattern 5 format:

   ```
   CONVERSATIONAL GOALS:

   [HIGH PRIORITY - Act on this urgently]
   Goal: {description}
   You should actively steer the conversation toward this goal. Bring it up naturally but persistently. This is your top priority right now.

   [MEDIUM PRIORITY - Work toward this when natural]
   Goal: {description}
   Look for natural openings to bring this up. Don't force it, but don't forget it either.

   [LOW PRIORITY - Keep in mind]
   Goal: {description}
   If the opportunity arises naturally, try to learn this. No need to push for it.
   ```

   - Goals are ordered by priority descending (High first, then Medium, then Low)
   - Use StringBuilder for efficient string building (same pattern as SystemInstructionBuilder)

**Important:** This class does NOT touch Firebase types. It produces plain string text that SystemInstructionBuilder will incorporate. Keep the Firebase boundary in SystemInstructionBuilder/PersonaSession only.

Use `using System; using System.Collections.Generic; using System.Text;` imports. Full XML doc comments.
  </action>
  <verify>File exists at Packages/com.google.ai-embodiment/Runtime/GoalManager.cs. Contains AddGoal, RemoveGoal, GetGoal, GetActiveGoals, HasGoals, ComposeGoalInstruction. ComposeGoalInstruction produces urgency-framed text with HIGH/MEDIUM/LOW sections ordered by priority.</verify>
  <done>GoalManager stores active goals, supports runtime add/remove/reprioritize, and composes urgency-framed instruction text ready for system instruction injection.</done>
</task>

</tasks>

<verification>
- All three files compile without errors in the AIEmbodiment namespace
- GoalPriority enum has exactly 3 values: Low, Medium, High
- ConversationalGoal validates constructor args and has mutable Priority
- GoalManager.ComposeGoalInstruction returns empty string when no goals, structured text when goals exist
- Goal ordering in composed text: High priority goals appear before Medium, Medium before Low
</verification>

<success_criteria>
GoalPriority, ConversationalGoal, and GoalManager exist as standalone types ready for PersonaSession and SystemInstructionBuilder integration in Plan 04-03. No existing files are modified.
</success_criteria>

<output>
After completion, create `.planning/phases/04-function-calling-and-conversational-goals/04-02-SUMMARY.md`
</output>
