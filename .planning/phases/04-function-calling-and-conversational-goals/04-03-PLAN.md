---
phase: 04-function-calling-and-conversational-goals
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/SystemInstructionBuilder.cs
  - Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
autonomous: true

must_haves:
  truths:
    - "Developer can register functions with schemas and handlers on PersonaSession before Connect()"
    - "When AI triggers a function call, the registered handler fires on the main thread with a FunctionCallContext"
    - "If a handler returns a non-null dictionary, the SDK sends it back to Gemini as a FunctionResponsePart automatically"
    - "If a handler throws, OnFunctionError fires and the conversation continues"
    - "Connect() passes registered function declarations as Tool[] to GetLiveModel"
    - "ProcessResponse handles LiveSessionToolCallCancellation by marking call IDs as cancelled"
    - "Developer can add, remove, and reprioritize goals at runtime via PersonaSession API"
    - "Goal changes trigger immediate system instruction update sent to the live session"
    - "SystemInstructionBuilder includes goal text in the initial system instruction when goals exist at connect time"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs"
      provides: "RegisterFunction, AddGoal, RemoveGoal, ReprioritizeGoal API, function dispatch, goal sync"
      contains: "RegisterFunction"
    - path: "Packages/com.google.ai-embodiment/Runtime/SystemInstructionBuilder.cs"
      provides: "Build overload accepting GoalManager for goal-inclusive instruction"
      contains: "GoalManager"
  key_links:
    - from: "PersonaSession.Connect"
      to: "FunctionRegistry.BuildTools"
      via: "tools parameter passed to ai.GetLiveModel"
      pattern: "tools.*BuildTools"
    - from: "PersonaSession (SyncPacket dispatch)"
      to: "FunctionRegistry.TryGetHandler"
      via: "intercept FunctionCall SyncPackets, invoke handler, send response"
      pattern: "TryGetHandler"
    - from: "PersonaSession (goal update)"
      to: "LiveSession.SendAsync"
      via: "system role ModelContent with full rebuilt instruction"
      pattern: "role.*system|SendAsync"
    - from: "SystemInstructionBuilder.Build"
      to: "GoalManager.ComposeGoalInstruction"
      via: "appends goal text to persona instruction"
      pattern: "ComposeGoalInstruction"
---

<objective>
Wire FunctionRegistry and GoalManager into PersonaSession and SystemInstructionBuilder, completing the full function calling dispatch pipeline and conversational goals runtime API.

Purpose: This plan connects all the infrastructure types from Plans 01 and 02 into the live session, enabling developers to register functions, dispatch handlers on function calls with automatic response round-trips, and manage conversational goals with immediate system instruction updates.

Output: Two modified existing files with the complete Phase 4 feature surface.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-function-calling-and-conversational-goals/04-CONTEXT.md
@.planning/phases/04-function-calling-and-conversational-goals/04-RESEARCH.md

Prior plan SUMMARYs (needed -- this plan uses types created by 04-01 and 04-02):
@.planning/phases/04-function-calling-and-conversational-goals/04-01-SUMMARY.md
@.planning/phases/04-function-calling-and-conversational-goals/04-02-SUMMARY.md

Source files to modify:
@Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
@Packages/com.google.ai-embodiment/Runtime/SystemInstructionBuilder.cs

Source files to reference:
@Packages/com.google.ai-embodiment/Runtime/FunctionRegistry.cs
@Packages/com.google.ai-embodiment/Runtime/FunctionCallContext.cs
@Packages/com.google.ai-embodiment/Runtime/GoalManager.cs
@Packages/com.google.ai-embodiment/Runtime/GoalPriority.cs
@Packages/com.google.ai-embodiment/Runtime/ConversationalGoal.cs
@Packages/com.google.ai-embodiment/Runtime/SyncPacket.cs
@Packages/com.google.ai-embodiment/Runtime/PacketAssembler.cs
@Assets/Firebase/FirebaseAI/FunctionCalling.cs
@Assets/Firebase/FirebaseAI/ModelContent.cs
@Assets/Firebase/FirebaseAI/LiveSessionResponse.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SystemInstructionBuilder goal-inclusive overload</name>
  <files>Packages/com.google.ai-embodiment/Runtime/SystemInstructionBuilder.cs</files>
  <action>
Add a new `Build` overload to `SystemInstructionBuilder` that accepts a `GoalManager`:

```csharp
public static ModelContent Build(PersonaConfig config, GoalManager goalManager)
```

**Implementation:**
1. Call the existing `Build(config)` logic to build the persona instruction string (refactor: extract the string-building part into a private helper method `BuildInstructionText(PersonaConfig config)` that returns the raw string, then have both `Build` overloads use it)
2. If `goalManager != null && goalManager.HasGoals`, append `goalManager.ComposeGoalInstruction()` to the instruction text (with a blank line separator)
3. Return `ModelContent.Text(fullText)`

The existing `Build(PersonaConfig config)` method must continue to work unchanged for backward compatibility. The new overload adds goal text when goals exist.

**Refactoring pattern:**
```csharp
// Private helper (extracted from existing Build)
private static string BuildInstructionText(PersonaConfig config) { ... }

// Existing method (unchanged behavior)
public static ModelContent Build(PersonaConfig config)
{
    return ModelContent.Text(BuildInstructionText(config));
}

// New overload
public static ModelContent Build(PersonaConfig config, GoalManager goalManager)
{
    var text = BuildInstructionText(config);
    if (goalManager != null && goalManager.HasGoals)
    {
        text += "\n\n" + goalManager.ComposeGoalInstruction();
    }
    return ModelContent.Text(text);
}
```

This preserves the existing Build(config) signature exactly -- no breaking changes.
  </action>
  <verify>SystemInstructionBuilder has both Build(PersonaConfig) and Build(PersonaConfig, GoalManager) methods. The original Build(PersonaConfig) still works identically. The new overload appends goal text when goals exist.</verify>
  <done>SystemInstructionBuilder can produce goal-inclusive system instructions for both initial connect and mid-session updates.</done>
</task>

<task type="auto">
  <name>Task 2: PersonaSession function calling and goal integration</name>
  <files>Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs</files>
  <action>
This task adds all Phase 4 functionality to PersonaSession. The changes are grouped by concern below.

**A. New fields (add near existing private fields):**
```csharp
private readonly FunctionRegistry _functionRegistry = new FunctionRegistry();
private readonly GoalManager _goalManager = new GoalManager();
```

**B. New events (add near existing events):**
```csharp
/// <summary>
/// Fires when a function handler throws an exception.
/// The conversation continues despite the error.
/// </summary>
public event Action<string, Exception> OnFunctionError;
```
First parameter is function name, second is the exception.

**C. Function registration API (add as public method):**
```csharp
/// <summary>
/// Registers a function that the AI can call during conversation.
/// Must be called before Connect() -- functions are fixed for the session lifetime.
/// </summary>
public void RegisterFunction(string name, FunctionDeclaration declaration, FunctionHandler handler)
{
    _functionRegistry.Register(name, declaration, handler);
}
```

**D. Goal management API (add as public methods):**
```csharp
/// <summary>Adds a conversational goal. Triggers immediate instruction update if connected.</summary>
public void AddGoal(string id, string description, GoalPriority priority)
{
    _goalManager.AddGoal(new ConversationalGoal(id, description, priority));
    SendGoalUpdate();
}

/// <summary>Removes a conversational goal by ID. Triggers immediate instruction update if connected.</summary>
public bool RemoveGoal(string goalId)
{
    bool removed = _goalManager.RemoveGoal(goalId);
    if (removed) SendGoalUpdate();
    return removed;
}

/// <summary>Changes a goal's priority. Triggers immediate instruction update if connected.</summary>
public bool ReprioritizeGoal(string goalId, GoalPriority newPriority)
{
    var goal = _goalManager.GetGoal(goalId);
    if (goal == null) return false;
    goal.Priority = newPriority;
    SendGoalUpdate();
    return true;
}
```

**E. SendGoalUpdate helper (private async method):**
```csharp
private async void SendGoalUpdate()
{
    if (_liveSession == null || State != SessionState.Connected) return;

    try
    {
        // REPLACE semantics: send FULL instruction (persona + goals) per Research Open Question 4
        var fullInstruction = SystemInstructionBuilder.Build(_config, _goalManager);

        await _liveSession.SendAsync(
            content: new ModelContent("system", new ModelContent.TextPart(
                fullInstruction.Parts[0] is ModelContent.TextPart tp ? tp.Text : ""
            )),
            turnComplete: false,
            cancellationToken: _sessionCts.Token
        );
    }
    catch (Exception ex)
    {
        MainThreadDispatcher.Enqueue(() =>
        {
            OnError?.Invoke(ex);
            Debug.LogError($"PersonaSession: Goal update failed: {ex.Message}");
        });
    }
}
```

IMPORTANT: The `ModelContent.Text()` factory creates content with role "user". For system instruction updates, we need role "system". Check how `ModelContent` constructors work. The constructor `ModelContent(string role, params Part[] parts)` should be available. Use:
```csharp
var instructionText = SystemInstructionBuilder.BuildInstructionText(_config, _goalManager);
```
Wait -- `BuildInstructionText` is private. Instead, build the full text directly:

Simplify: Use `SystemInstructionBuilder.Build(_config, _goalManager)` to get the ModelContent, then extract the text from it. OR, since we know SystemInstructionBuilder returns `ModelContent.Text(str)` which has role "user", we need to rebuild with role "system". The cleanest approach:

Add a public helper to SystemInstructionBuilder: `public static string BuildText(PersonaConfig config, GoalManager goalManager)` that returns the raw string (make `BuildInstructionText` internal or add this public variant). Then in PersonaSession:

```csharp
// Actually, the simplest approach: just call the private helper's logic
// OR expose it. Let's make BuildInstructionText internal.
```

REVISED APPROACH: In Task 1, make `BuildInstructionText` an `internal` method (not private), so PersonaSession can use it:

```csharp
internal static string BuildInstructionText(PersonaConfig config) { ... }

internal static string BuildInstructionText(PersonaConfig config, GoalManager goalManager)
{
    var text = BuildInstructionText(config);
    if (goalManager != null && goalManager.HasGoals)
        text += "\n\n" + goalManager.ComposeGoalInstruction();
    return text;
}
```

Then in SendGoalUpdate:
```csharp
var text = SystemInstructionBuilder.BuildInstructionText(_config, _goalManager);
var content = new ModelContent("system", new ModelContent.TextPart(text));
await _liveSession.SendAsync(content: content, turnComplete: false, cancellationToken: _sessionCts.Token);
```

This requires updating Task 1 slightly -- make sure `BuildInstructionText` is `internal` not `private`.

**F. Modify Connect() (3 changes):**

1. Pass tools to GetLiveModel:
```csharp
var tools = _functionRegistry.HasRegistrations ? _functionRegistry.BuildTools() : null;

var liveModel = ai.GetLiveModel(
    modelName: _config.modelName,
    liveGenerationConfig: liveConfig,
    tools: tools,                                        // NEW
    systemInstruction: SystemInstructionBuilder.Build(_config, _goalManager)  // CHANGED: include goals
);
```

2. Replace `SystemInstructionBuilder.Build(_config)` with `SystemInstructionBuilder.Build(_config, _goalManager)` so initial goals are included.

3. Set up the SyncPacket callback to intercept FunctionCall packets for dispatch. Replace the existing callback:
```csharp
// BEFORE:
_packetAssembler.SetPacketCallback(packet => OnSyncPacket?.Invoke(packet));

// AFTER:
_packetAssembler.SetPacketCallback(HandleSyncPacket);
```

**G. HandleSyncPacket method (private, on main thread):**
```csharp
private void HandleSyncPacket(SyncPacket packet)
{
    if (packet.Type == SyncPacketType.FunctionCall && !string.IsNullOrEmpty(packet.FunctionName))
    {
        DispatchFunctionCall(packet);
    }

    // Always forward to developer subscribers (they can observe function calls too)
    OnSyncPacket?.Invoke(packet);
}
```

**H. DispatchFunctionCall method (private):**
```csharp
private void DispatchFunctionCall(SyncPacket packet)
{
    // Check cancellation (Pitfall 3: race condition)
    if (packet.FunctionId != null && _functionRegistry.IsCancelled(packet.FunctionId))
    {
        return; // Call was cancelled by user interruption, skip dispatch
    }

    if (!_functionRegistry.TryGetHandler(packet.FunctionName, out var handler))
    {
        Debug.LogWarning($"PersonaSession: No handler registered for function '{packet.FunctionName}'");
        return;
    }

    IDictionary<string, object> result = null;
    try
    {
        var context = new FunctionCallContext(packet.FunctionName, packet.FunctionId, packet.FunctionArgs);
        result = handler(context);
    }
    catch (Exception ex)
    {
        OnFunctionError?.Invoke(packet.FunctionName, ex);
        Debug.LogError($"PersonaSession: Function handler '{packet.FunctionName}' threw: {ex.Message}");
        return; // Don't send response on error
    }

    // If handler returned a value, send it back to Gemini (Pitfall 1: timing)
    if (result != null && packet.FunctionId != null)
    {
        _ = SendFunctionResponseAsync(packet.FunctionName, result, packet.FunctionId);
    }
}
```

**I. SendFunctionResponseAsync (private async method):**
```csharp
private async Task SendFunctionResponseAsync(string name, IDictionary<string, object> result, string callId)
{
    try
    {
        if (_liveSession == null || State != SessionState.Connected) return;

        // Check cancellation one more time before sending (Pitfall 3)
        if (_functionRegistry.IsCancelled(callId)) return;

        var response = ModelContent.FunctionResponse(name, result, callId);
        await _liveSession.SendAsync(content: response, cancellationToken: _sessionCts.Token);
    }
    catch (Exception ex)
    {
        MainThreadDispatcher.Enqueue(() =>
        {
            OnError?.Invoke(ex);
            Debug.LogError($"PersonaSession: Function response send failed: {ex.Message}");
        });
    }
}
```

**J. ProcessResponse: add LiveSessionToolCallCancellation handling:**

After the existing `else if (response.Message is LiveSessionToolCall toolCall)` block, add:
```csharp
else if (response.Message is LiveSessionToolCallCancellation cancellation)
{
    foreach (var id in cancellation.FunctionIds)
    {
        var localId = id;
        MainThreadDispatcher.Enqueue(() => _functionRegistry.MarkCancelled(localId));
    }
}
```

**K. Cleanup: Reset function registry state in Disconnect() and OnDestroy():**
- No special cleanup needed for FunctionRegistry (it persists across reconnects -- registrations survive)
- GoalManager persists too (goals survive disconnect/reconnect)
- No changes to Disconnect/OnDestroy for these

**Summary of all PersonaSession changes:**
1. Two new fields: `_functionRegistry`, `_goalManager`
2. One new event: `OnFunctionError`
3. Three new public methods: `RegisterFunction`, `AddGoal`, `RemoveGoal`, `ReprioritizeGoal` (4 methods)
4. Four new private methods: `SendGoalUpdate`, `HandleSyncPacket`, `DispatchFunctionCall`, `SendFunctionResponseAsync`
5. Connect() modified: tools parameter, goal-inclusive system instruction, HandleSyncPacket callback
6. ProcessResponse modified: LiveSessionToolCallCancellation handling added
  </action>
  <verify>
PersonaSession compiles with all new methods. Verify the following by reading the file:
1. RegisterFunction method exists and delegates to _functionRegistry.Register
2. AddGoal/RemoveGoal/ReprioritizeGoal methods exist and call SendGoalUpdate
3. Connect() passes _functionRegistry.BuildTools() to GetLiveModel
4. Connect() uses SystemInstructionBuilder.Build(_config, _goalManager)
5. HandleSyncPacket intercepts FunctionCall packets and calls DispatchFunctionCall
6. DispatchFunctionCall checks cancellation, invokes handler, sends response if non-null
7. ProcessResponse handles LiveSessionToolCallCancellation
8. OnFunctionError event declared
  </verify>
  <done>PersonaSession exposes the complete function calling and conversational goals developer API. Functions register before Connect() and dispatch via SyncPacket pipeline with automatic response round-trip. Goals are managed at runtime with immediate system instruction updates to the live session.</done>
</task>

</tasks>

<verification>
- SystemInstructionBuilder.Build(config, goalManager) produces instruction text with goal framing
- PersonaSession.RegisterFunction stores declaration+handler in FunctionRegistry
- PersonaSession.Connect passes tools and goal-inclusive instruction to GetLiveModel
- FunctionCall SyncPackets dispatch to registered handlers with FunctionCallContext
- Handler return values are sent back as FunctionResponsePart via SendAsync
- Handler exceptions fire OnFunctionError without crashing the session
- LiveSessionToolCallCancellation marks call IDs as cancelled in FunctionRegistry
- AddGoal/RemoveGoal/ReprioritizeGoal trigger immediate system instruction update via SendAsync with role "system"
- All existing events and behavior remain backward-compatible
</verification>

<success_criteria>
Complete Phase 4 feature surface operational. Developer can register functions, receive dispatched handler calls with typed arguments, get automatic response round-trips, manage conversational goals at runtime, and have the AI's system instruction updated immediately on goal changes. Requirements FUNC-01 through FUNC-03, GOAL-01 through GOAL-04 verified through the integration. FUNC-04 (built-in emote) is N/A per CONTEXT.md decision (no built-in functions). GOAL-05 (goal_reached) is developer-managed per CONTEXT.md decision.
</success_criteria>

<output>
After completion, create `.planning/phases/04-function-calling-and-conversational-goals/04-03-SUMMARY.md`
</output>
