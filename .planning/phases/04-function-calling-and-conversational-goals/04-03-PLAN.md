---
phase: 04-function-calling-and-conversational-goals
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/SystemInstructionBuilder.cs
  - Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
autonomous: true

must_haves:
  truths:
    - "Developer can register functions with schemas and handlers on PersonaSession before Connect()"
    - "When AI triggers a function call, the registered handler fires on the main thread with a FunctionCallContext"
    - "If a handler returns a non-null dictionary, the SDK sends it back to Gemini as a FunctionResponsePart automatically"
    - "If a handler throws, OnFunctionError fires and the conversation continues"
    - "Connect() passes registered function declarations as Tool[] to GetLiveModel"
    - "ProcessResponse handles LiveSessionToolCallCancellation by marking call IDs as cancelled"
    - "Developer can add, remove, and reprioritize goals at runtime via PersonaSession API"
    - "Goal changes trigger immediate system instruction update sent to the live session"
    - "SystemInstructionBuilder includes goal text in the initial system instruction when goals exist at connect time"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs"
      provides: "RegisterFunction, AddGoal, RemoveGoal, ReprioritizeGoal API, function dispatch, goal sync"
      contains: "RegisterFunction"
    - path: "Packages/com.google.ai-embodiment/Runtime/SystemInstructionBuilder.cs"
      provides: "Build overload accepting GoalManager, internal BuildInstructionText for raw string access"
      contains: "GoalManager"
  key_links:
    - from: "PersonaSession.Connect"
      to: "FunctionRegistry.BuildTools"
      via: "tools parameter passed to ai.GetLiveModel"
      pattern: "tools.*BuildTools"
    - from: "PersonaSession (SyncPacket dispatch)"
      to: "FunctionRegistry.TryGetHandler"
      via: "intercept FunctionCall SyncPackets, invoke handler, send response"
      pattern: "TryGetHandler"
    - from: "PersonaSession (goal update)"
      to: "LiveSession.SendAsync"
      via: "system role ModelContent with full rebuilt instruction"
      pattern: "role.*system|SendAsync"
    - from: "SystemInstructionBuilder.Build"
      to: "GoalManager.ComposeGoalInstruction"
      via: "appends goal text to persona instruction"
      pattern: "ComposeGoalInstruction"
---

<objective>
Wire FunctionRegistry and GoalManager into PersonaSession and SystemInstructionBuilder, completing the full function calling dispatch pipeline and conversational goals runtime API.

Purpose: This plan connects all the infrastructure types from Plans 01 and 02 into the live session, enabling developers to register functions, dispatch handlers on function calls with automatic response round-trips, and manage conversational goals with immediate system instruction updates.

Output: Two modified existing files with the complete Phase 4 feature surface.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-function-calling-and-conversational-goals/04-CONTEXT.md
@.planning/phases/04-function-calling-and-conversational-goals/04-RESEARCH.md

Prior plan SUMMARYs (needed -- this plan uses types created by 04-01 and 04-02):
@.planning/phases/04-function-calling-and-conversational-goals/04-01-SUMMARY.md
@.planning/phases/04-function-calling-and-conversational-goals/04-02-SUMMARY.md

Source files to modify:
@Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
@Packages/com.google.ai-embodiment/Runtime/SystemInstructionBuilder.cs

Source files to reference:
@Packages/com.google.ai-embodiment/Runtime/FunctionRegistry.cs
@Packages/com.google.ai-embodiment/Runtime/FunctionCallContext.cs
@Packages/com.google.ai-embodiment/Runtime/GoalManager.cs
@Packages/com.google.ai-embodiment/Runtime/GoalPriority.cs
@Packages/com.google.ai-embodiment/Runtime/ConversationalGoal.cs
@Packages/com.google.ai-embodiment/Runtime/SyncPacket.cs
@Packages/com.google.ai-embodiment/Runtime/PacketAssembler.cs
@Assets/Firebase/FirebaseAI/FunctionCalling.cs
@Assets/Firebase/FirebaseAI/ModelContent.cs
@Assets/Firebase/FirebaseAI/LiveSessionResponse.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SystemInstructionBuilder goal-inclusive overload and internal text helper</name>
  <files>Packages/com.google.ai-embodiment/Runtime/SystemInstructionBuilder.cs</files>
  <action>
Add goal support to `SystemInstructionBuilder` with two changes: extract a reusable text helper and add a new `Build` overload.

**Step 1: Extract BuildInstructionText as internal static:**

Refactor the existing `Build(PersonaConfig config)` method by extracting its string-building logic into an `internal static` helper. This must be `internal` (not private) because PersonaSession needs to call it directly to construct a `role: "system"` ModelContent for mid-session goal updates.

```csharp
/// <summary>
/// Builds the raw instruction text string from persona config.
/// Internal so PersonaSession can access it for mid-session instruction updates.
/// </summary>
internal static string BuildInstructionText(PersonaConfig config) { ... }
```

Move the existing string-building logic from `Build` into this method. Then have `Build(PersonaConfig)` delegate to it:

```csharp
public static ModelContent Build(PersonaConfig config)
{
    return ModelContent.Text(BuildInstructionText(config));
}
```

**Step 2: Add two-parameter BuildInstructionText overload:**

```csharp
/// <summary>
/// Builds instruction text including conversational goal framing when goals exist.
/// Internal so PersonaSession can access it for mid-session instruction updates.
/// </summary>
internal static string BuildInstructionText(PersonaConfig config, GoalManager goalManager)
{
    var text = BuildInstructionText(config);
    if (goalManager != null && goalManager.HasGoals)
    {
        text += "\n\n" + goalManager.ComposeGoalInstruction();
    }
    return text;
}
```

**Step 3: Add new Build overload accepting GoalManager:**

```csharp
/// <summary>
/// Builds a system instruction ModelContent including conversational goals.
/// </summary>
public static ModelContent Build(PersonaConfig config, GoalManager goalManager)
{
    return ModelContent.Text(BuildInstructionText(config, goalManager));
}
```

The existing `Build(PersonaConfig config)` method must continue to work unchanged for backward compatibility.
  </action>
  <verify>SystemInstructionBuilder has: (1) `internal static string BuildInstructionText(PersonaConfig)`, (2) `internal static string BuildInstructionText(PersonaConfig, GoalManager)`, (3) existing `public static ModelContent Build(PersonaConfig)` unchanged behavior, (4) new `public static ModelContent Build(PersonaConfig, GoalManager)`. Verify BuildInstructionText is internal, not private.</verify>
  <done>SystemInstructionBuilder can produce goal-inclusive system instructions via both ModelContent (for Connect) and raw string (for mid-session updates with custom role).</done>
</task>

<task type="auto">
  <name>Task 2: PersonaSession function calling integration</name>
  <files>Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs</files>
  <action>
This task adds function calling to PersonaSession. Goal integration is in Task 3.

**A. New field (add near existing private fields):**
```csharp
private readonly FunctionRegistry _functionRegistry = new FunctionRegistry();
```

**B. New event (add near existing events):**
```csharp
/// <summary>
/// Fires when a function handler throws an exception.
/// The conversation continues despite the error.
/// </summary>
public event Action<string, Exception> OnFunctionError;
```
First parameter is function name, second is the exception.

**C. Function registration API (add as public method):**
```csharp
/// <summary>
/// Registers a function that the AI can call during conversation.
/// Must be called before Connect() -- functions are fixed for the session lifetime.
/// </summary>
public void RegisterFunction(string name, FunctionDeclaration declaration, FunctionHandler handler)
{
    _functionRegistry.Register(name, declaration, handler);
}
```

**D. Modify Connect() for tools and callback (2 changes):**

1. Pass tools to GetLiveModel:
```csharp
var tools = _functionRegistry.HasRegistrations ? _functionRegistry.BuildTools() : null;

var liveModel = ai.GetLiveModel(
    modelName: _config.modelName,
    liveGenerationConfig: liveConfig,
    tools: tools,                    // NEW
    systemInstruction: ...           // unchanged for now, Task 3 will update this
);
```

2. Replace the existing SyncPacket callback to intercept function calls:
```csharp
// BEFORE:
_packetAssembler.SetPacketCallback(packet => OnSyncPacket?.Invoke(packet));

// AFTER:
_packetAssembler.SetPacketCallback(HandleSyncPacket);
```

**E. HandleSyncPacket method (private, on main thread):**
```csharp
private void HandleSyncPacket(SyncPacket packet)
{
    if (packet.Type == SyncPacketType.FunctionCall && !string.IsNullOrEmpty(packet.FunctionName))
    {
        DispatchFunctionCall(packet);
    }

    // Always forward to developer subscribers (they can observe function calls too)
    OnSyncPacket?.Invoke(packet);
}
```

**F. DispatchFunctionCall method (private):**
```csharp
private void DispatchFunctionCall(SyncPacket packet)
{
    // Check cancellation (Pitfall 3: race condition)
    if (packet.FunctionId != null && _functionRegistry.IsCancelled(packet.FunctionId))
    {
        return; // Call was cancelled by user interruption, skip dispatch
    }

    if (!_functionRegistry.TryGetHandler(packet.FunctionName, out var handler))
    {
        Debug.LogWarning($"PersonaSession: No handler registered for function '{packet.FunctionName}'");
        return;
    }

    IDictionary<string, object> result = null;
    try
    {
        var context = new FunctionCallContext(packet.FunctionName, packet.FunctionId, packet.FunctionArgs);
        result = handler(context);
    }
    catch (Exception ex)
    {
        OnFunctionError?.Invoke(packet.FunctionName, ex);
        Debug.LogError($"PersonaSession: Function handler '{packet.FunctionName}' threw: {ex.Message}");
        return; // Don't send response on error
    }

    // If handler returned a value, send it back to Gemini (Pitfall 1: timing)
    if (result != null && packet.FunctionId != null)
    {
        _ = SendFunctionResponseAsync(packet.FunctionName, result, packet.FunctionId);
    }
}
```

**G. SendFunctionResponseAsync (private async method):**
```csharp
private async Task SendFunctionResponseAsync(string name, IDictionary<string, object> result, string callId)
{
    try
    {
        if (_liveSession == null || State != SessionState.Connected) return;

        // Check cancellation one more time before sending (Pitfall 3)
        if (_functionRegistry.IsCancelled(callId)) return;

        var response = ModelContent.FunctionResponse(name, result, callId);
        await _liveSession.SendAsync(content: response, cancellationToken: _sessionCts.Token);
    }
    catch (Exception ex)
    {
        MainThreadDispatcher.Enqueue(() =>
        {
            OnError?.Invoke(ex);
            Debug.LogError($"PersonaSession: Function response send failed: {ex.Message}");
        });
    }
}
```

**H. ProcessResponse: add LiveSessionToolCallCancellation handling:**

After the existing `else if (response.Message is LiveSessionToolCall toolCall)` block, add:
```csharp
else if (response.Message is LiveSessionToolCallCancellation cancellation)
{
    foreach (var id in cancellation.FunctionIds)
    {
        var localId = id;
        MainThreadDispatcher.Enqueue(() => _functionRegistry.MarkCancelled(localId));
    }
}
```

**No cleanup changes needed:** FunctionRegistry persists across reconnects (registrations survive disconnect).
  </action>
  <verify>
PersonaSession compiles with function calling support. Verify by reading the file:
1. _functionRegistry field exists
2. OnFunctionError event declared
3. RegisterFunction method exists and delegates to _functionRegistry.Register
4. Connect() passes _functionRegistry.BuildTools() to GetLiveModel
5. HandleSyncPacket intercepts FunctionCall packets and calls DispatchFunctionCall
6. DispatchFunctionCall checks cancellation, invokes handler, sends response if non-null
7. SendFunctionResponseAsync sends FunctionResponsePart via SendAsync
8. ProcessResponse handles LiveSessionToolCallCancellation
  </verify>
  <done>PersonaSession exposes the complete function calling developer API. Functions register before Connect(), dispatch via SyncPacket pipeline with automatic response round-trip, and cancellations are tracked.</done>
</task>

<task type="auto">
  <name>Task 3: PersonaSession goal management integration</name>
  <files>Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs</files>
  <action>
This task adds conversational goal management to PersonaSession. Function calling was added in Task 2.

**A. New field (add near _functionRegistry):**
```csharp
private readonly GoalManager _goalManager = new GoalManager();
```

**B. Goal management API (add as public methods):**
```csharp
/// <summary>Adds a conversational goal. Triggers immediate instruction update if connected.</summary>
public void AddGoal(string id, string description, GoalPriority priority)
{
    _goalManager.AddGoal(new ConversationalGoal(id, description, priority));
    SendGoalUpdate();
}

/// <summary>Removes a conversational goal by ID. Triggers immediate instruction update if connected.</summary>
public bool RemoveGoal(string goalId)
{
    bool removed = _goalManager.RemoveGoal(goalId);
    if (removed) SendGoalUpdate();
    return removed;
}

/// <summary>Changes a goal's priority. Triggers immediate instruction update if connected.</summary>
public bool ReprioritizeGoal(string goalId, GoalPriority newPriority)
{
    var goal = _goalManager.GetGoal(goalId);
    if (goal == null) return false;
    goal.Priority = newPriority;
    SendGoalUpdate();
    return true;
}
```

**C. SendGoalUpdate helper (private async method):**

Mid-session system instruction update strategy: send a `role: "system"` ModelContent via SendAsync containing the full rebuilt instruction (persona + goals). This uses REPLACE semantics per Research Open Question 4.

**Fallback strategy:** If the `role: "system"` clientContent wire format is rejected by the Gemini Live API (returns an error or is silently ignored), the fallback is to disconnect and reconnect the session with the updated instruction passed to GetLiveModel. This is a heavier operation but guaranteed to work since system instructions are always honored at session start. The SendGoalUpdate catch block already logs errors via OnError, which gives developers visibility into whether the mid-session approach is working.

```csharp
private async void SendGoalUpdate()
{
    if (_liveSession == null || State != SessionState.Connected) return;

    try
    {
        var text = SystemInstructionBuilder.BuildInstructionText(_config, _goalManager);
        var content = new ModelContent("system", new ModelContent.TextPart(text));
        await _liveSession.SendAsync(content: content, turnComplete: false, cancellationToken: _sessionCts.Token);
    }
    catch (Exception ex)
    {
        // If role "system" clientContent is rejected, this will fire.
        // Fallback: developer can listen to OnError, disconnect, and reconnect.
        // A future enhancement could auto-reconnect here.
        MainThreadDispatcher.Enqueue(() =>
        {
            OnError?.Invoke(ex);
            Debug.LogError($"PersonaSession: Goal update failed: {ex.Message}. " +
                "Fallback: disconnect and reconnect to apply goal changes via initial system instruction.");
        });
    }
}
```

**D. Modify Connect() for goal-inclusive system instruction:**

Update the SystemInstructionBuilder.Build call in Connect() to include the GoalManager:
```csharp
// BEFORE (from existing code or Task 2):
systemInstruction: SystemInstructionBuilder.Build(_config)

// AFTER:
systemInstruction: SystemInstructionBuilder.Build(_config, _goalManager)
```

This ensures goals added before Connect() are included in the initial system instruction.

**No cleanup changes needed:** GoalManager persists across reconnects (goals survive disconnect).
  </action>
  <verify>
PersonaSession compiles with goal management support. Verify by reading the file:
1. _goalManager field exists
2. AddGoal/RemoveGoal/ReprioritizeGoal methods exist and call SendGoalUpdate
3. SendGoalUpdate builds text via SystemInstructionBuilder.BuildInstructionText(_config, _goalManager) (internal method from Task 1)
4. SendGoalUpdate sends ModelContent with role "system"
5. SendGoalUpdate catch block logs fallback guidance
6. Connect() uses SystemInstructionBuilder.Build(_config, _goalManager) for initial instruction
  </verify>
  <done>PersonaSession exposes the complete conversational goals developer API. Goals can be added, removed, and reprioritized at runtime with immediate system instruction updates. Fallback strategy documented for mid-session update rejection.</done>
</task>

</tasks>

<verification>
- SystemInstructionBuilder.BuildInstructionText is internal (not private), both single-param and two-param overloads
- SystemInstructionBuilder.Build(config, goalManager) produces instruction text with goal framing
- PersonaSession.RegisterFunction stores declaration+handler in FunctionRegistry
- PersonaSession.Connect passes tools and goal-inclusive instruction to GetLiveModel
- FunctionCall SyncPackets dispatch to registered handlers with FunctionCallContext
- Handler return values are sent back as FunctionResponsePart via SendAsync
- Handler exceptions fire OnFunctionError without crashing the session
- LiveSessionToolCallCancellation marks call IDs as cancelled in FunctionRegistry
- AddGoal/RemoveGoal/ReprioritizeGoal trigger immediate system instruction update via SendAsync with role "system"
- SendGoalUpdate includes fallback strategy documentation (session reconnect if role "system" is rejected)
- All existing events and behavior remain backward-compatible
</verification>

<success_criteria>
Complete Phase 4 feature surface operational. Developer can register functions, receive dispatched handler calls with typed arguments, get automatic response round-trips, manage conversational goals at runtime, and have the AI's system instruction updated immediately on goal changes. Requirements FUNC-01 through FUNC-03, GOAL-01 through GOAL-04 verified through the integration. FUNC-04 (built-in emote) is N/A per CONTEXT.md decision (no built-in functions). GOAL-05 (goal_reached) is developer-managed per CONTEXT.md decision.
</success_criteria>

<output>
After completion, create `.planning/phases/04-function-calling-and-conversational-goals/04-03-SUMMARY.md`
</output>
