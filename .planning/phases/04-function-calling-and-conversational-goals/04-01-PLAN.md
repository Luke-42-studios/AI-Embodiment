---
phase: 04-function-calling-and-conversational-goals
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/FunctionCallContext.cs
  - Packages/com.google.ai-embodiment/Runtime/FunctionRegistry.cs
autonomous: true

must_haves:
  truths:
    - "FunctionCallContext provides typed accessors (GetString, GetInt, GetFloat, GetBool) that safely coerce MiniJSON-deserialized types"
    - "FunctionRegistry maps function names to FunctionDeclaration + handler delegate pairs"
    - "FunctionRegistry.BuildTools() produces a Tool[] array from registered declarations"
    - "FunctionRegistry rejects registration after freeze (post-Connect)"
    - "FunctionRegistry tracks pending call IDs and supports cancellation"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/FunctionCallContext.cs"
      provides: "Typed argument accessor for function call handlers"
      contains: "class FunctionCallContext"
    - path: "Packages/com.google.ai-embodiment/Runtime/FunctionRegistry.cs"
      provides: "Function name to declaration+handler mapping with freeze, build, dispatch, and cancellation"
      contains: "class FunctionRegistry"
  key_links:
    - from: "FunctionCallContext.GetInt"
      to: "IReadOnlyDictionary<string, object>"
      via: "double-to-int safe conversion (MiniJSON returns double for all numbers)"
      pattern: "Convert\\.ToInt32|\\(int\\)"
    - from: "FunctionRegistry.BuildTools"
      to: "Firebase.AI.Tool"
      via: "new Tool(declarations) from registered FunctionDeclaration array"
      pattern: "new Tool"
---

<objective>
Create the function calling infrastructure types: FunctionCallContext (typed argument wrapper) and FunctionRegistry (registration, lookup, freeze, build, and cancellation tracking).

Purpose: These types form the foundation that PersonaSession will use to register developer functions before Connect() and dispatch them when the AI triggers function calls. They must be created before PersonaSession integration.

Output: Two new C# files in the Runtime directory.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-function-calling-and-conversational-goals/04-CONTEXT.md
@.planning/phases/04-function-calling-and-conversational-goals/04-RESEARCH.md

Source files to reference for patterns and types:
@Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
@Packages/com.google.ai-embodiment/Runtime/SyncPacket.cs
@Assets/Firebase/FirebaseAI/FunctionCalling.cs
@Assets/Firebase/FirebaseAI/ModelContent.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: FunctionCallContext typed argument wrapper</name>
  <files>Packages/com.google.ai-embodiment/Runtime/FunctionCallContext.cs</files>
  <action>
Create `FunctionCallContext` class in namespace `AIEmbodiment`.

This wraps `IReadOnlyDictionary<string, object>` (from `FunctionCallPart.Args`) with typed accessors that handle MiniJSON type coercion (Pitfall 4 from Research).

**Properties:**
- `string FunctionName { get; }` -- the function name from the AI
- `string CallId { get; }` -- the function call ID for response correlation (from `FunctionCallPart.Id`)
- `IReadOnlyDictionary<string, object> RawArgs { get; }` -- raw arguments for advanced use

**Constructor:** `FunctionCallContext(string functionName, string callId, IReadOnlyDictionary<string, object> args)`

**Typed accessor methods (all with default value parameter):**
- `string GetString(string key, string defaultValue = null)` -- returns value as string, or default if missing/null
- `int GetInt(string key, int defaultValue = 0)` -- MiniJSON returns `double` for all numbers, so use `Convert.ToInt32` for safe coercion
- `float GetFloat(string key, float defaultValue = 0f)` -- use `Convert.ToSingle` for safe coercion from double
- `bool GetBool(string key, bool defaultValue = false)` -- direct cast (MiniJSON returns bool for booleans)
- `IReadOnlyDictionary<string, object> GetObject(string key)` -- returns nested dictionary, null if missing
- `IReadOnlyList<object> GetArray(string key)` -- returns list, null if missing

**Each accessor pattern:**
1. Check `RawArgs.TryGetValue(key, out var value)` -- return default if key missing
2. Check `value == null` -- return default if null
3. Try conversion with appropriate Convert method
4. Catch `InvalidCastException` / `FormatException` and return default (defensive)

Use `using System; using System.Collections.Generic;` imports. Follow the same namespace and XML doc style as SyncPacket.cs (full `<summary>` and `<param>` docs).
  </action>
  <verify>File exists at Packages/com.google.ai-embodiment/Runtime/FunctionCallContext.cs. Contains class with FunctionName, CallId, RawArgs properties and all 6 typed accessor methods (GetString, GetInt, GetFloat, GetBool, GetObject, GetArray). Each accessor handles the null/missing case defensively.</verify>
  <done>FunctionCallContext class provides typed accessors that safely coerce MiniJSON-deserialized types (double to int, double to float) with default value fallbacks for missing keys.</done>
</task>

<task type="auto">
  <name>Task 2: FunctionRegistry with registration, freeze, build, dispatch, and cancellation</name>
  <files>Packages/com.google.ai-embodiment/Runtime/FunctionRegistry.cs</files>
  <action>
Create `FunctionRegistry` class in namespace `AIEmbodiment`.

**Delegate type (define inside FunctionRegistry or at namespace level):**
```csharp
public delegate IDictionary<string, object> FunctionHandler(FunctionCallContext context);
```
- Returns `IDictionary<string, object>` or null
- null return = fire-and-forget (no response sent back to model)
- non-null return = response dictionary sent back automatically

**Private state:**
- `Dictionary<string, (FunctionDeclaration declaration, FunctionHandler handler)>` -- maps function name to declaration+handler pair
- `HashSet<string> _cancelledIds` -- tracks cancelled function call IDs (for Pitfall 3: race condition)
- `bool _frozen` -- set to true after BuildTools() is called, prevents further registration

**Public methods:**

1. `void Register(FunctionDeclaration declaration, FunctionHandler handler)`
   - Throws `InvalidOperationException` if `_frozen` (anti-pattern from Research: registering after Connect)
   - Stores the declaration+handler pair keyed by the declaration's name
   - Problem: `FunctionDeclaration.Name` is private. Solution: accept the name as a separate parameter OR store the declaration and handler keyed by a name the developer passes. Looking at the FunctionDeclaration constructor, the name is passed there but not accessible. So change the signature to:
     `void Register(string name, FunctionDeclaration declaration, FunctionHandler handler)`
   - This also validates that name is not null/empty

2. `Tool[] BuildTools()`
   - Sets `_frozen = true`
   - If no functions registered, returns null (no tools to pass)
   - Creates a single `Tool` containing all registered `FunctionDeclaration` instances
   - Returns `new Tool[] { new Tool(declarations) }` where declarations is the array of all registered FunctionDeclaration values

3. `bool TryGetHandler(string functionName, out FunctionHandler handler)`
   - Looks up handler by function name
   - Returns false if not found

4. `void MarkCancelled(string callId)`
   - Adds callId to `_cancelledIds` set

5. `bool IsCancelled(string callId)`
   - Returns true if callId is in `_cancelledIds`, then removes it (one-shot check)

6. `bool HasRegistrations` (property)
   - Returns true if any functions are registered

**Important:** Use `using Firebase.AI;` for FunctionDeclaration and Tool types. Use `using System; using System.Collections.Generic;`.

Follow existing code style: full XML doc comments on all public members, `AIEmbodiment` namespace.
  </action>
  <verify>File exists at Packages/com.google.ai-embodiment/Runtime/FunctionRegistry.cs. Contains FunctionHandler delegate, FunctionRegistry class with Register, BuildTools, TryGetHandler, MarkCancelled, IsCancelled methods and HasRegistrations property. Register throws InvalidOperationException when frozen. BuildTools produces Tool[] from declarations.</verify>
  <done>FunctionRegistry maps function names to FunctionDeclaration+handler pairs, freezes after BuildTools(), tracks pending call cancellations, and produces Tool[] for the Firebase GetLiveModel call.</done>
</task>

</tasks>

<verification>
- Both files compile without errors in the AIEmbodiment namespace
- FunctionCallContext handles MiniJSON type coercion (double -> int, double -> float)
- FunctionRegistry.Register throws after freeze
- FunctionRegistry.BuildTools returns null when empty, Tool[] when populated
- FunctionRegistry cancellation tracking works (MarkCancelled -> IsCancelled returns true once)
</verification>

<success_criteria>
FunctionCallContext and FunctionRegistry exist as standalone types ready for PersonaSession integration in Plan 04-02. No existing files are modified.
</success_criteria>

<output>
After completion, create `.planning/phases/04-function-calling-and-conversational-goals/04-01-SUMMARY.md`
</output>
