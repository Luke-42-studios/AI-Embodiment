---
phase: 10-function-calling-and-goals-migration
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
  - Packages/com.google.ai-embodiment/Runtime/SystemInstructionBuilder.cs
autonomous: true

must_haves:
  truths:
    - "RegisterFunction accepts a FunctionDeclaration and tool declarations flow into the setup handshake at Connect() time"
    - "AI-triggered function calls carry the function call ID through to the handler and back via toolResponse"
    - "Function call cancellations from the server cancel pending dispatches"
    - "Prompt-based fallback: when enabled, function instructions are injected into system prompt and [CALL: ...] tags in transcription trigger handlers"
    - "Goal updates mid-session log a clear warning that changes apply on next connection"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs"
      provides: "Full function calling wiring (native + prompt-based), goal update finalization"
      contains: "SendToolResponse"
    - path: "Packages/com.google.ai-embodiment/Runtime/SystemInstructionBuilder.cs"
      provides: "Prompt-based function instructions appended to system instruction"
      contains: "functionInstructions"
  key_links:
    - from: "PersonaSession.cs"
      to: "GeminiLiveClient.cs"
      via: "Connect passes ToolsJson; HandleFunctionCallEvent passes FunctionId; SendFunctionResponse calls SendToolResponse"
      pattern: "liveConfig\\.ToolsJson|_client\\.SendToolResponse"
    - from: "PersonaSession.cs"
      to: "FunctionRegistry.cs"
      via: "RegisterFunction passes declaration; Connect freezes registry and builds tools JSON"
      pattern: "_functionRegistry\\.Register.*declaration|_functionRegistry\\.BuildToolsJson"
    - from: "PersonaSession.cs"
      to: "SystemInstructionBuilder.cs"
      via: "Connect builds system instruction with optional prompt-based function text"
      pattern: "SystemInstructionBuilder\\.Build"
    - from: "PersonaSession.cs"
      to: "PacketAssembler.cs"
      via: "HandleFunctionCallEvent passes FunctionId to AddFunctionCall"
      pattern: "_packetAssembler\\?\\.AddFunctionCall.*FunctionId"
---

<objective>
Wire function calling and goal updates into PersonaSession: connect FunctionDeclaration registration to the setup handshake, implement the full function call -> handler -> toolResponse cycle with ID correlation, add prompt-based fallback parsing from transcription, handle FunctionCallCancellation events, and finalize SendGoalUpdate with the proper warning log.

Purpose: Completes MIG-04 (function calling via WebSocket) and MIG-05 (goal system migration) requirements.
Output: Updated PersonaSession.cs and SystemInstructionBuilder.cs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-function-calling-and-goals-migration/10-CONTEXT.md
@.planning/phases/10-function-calling-and-goals-migration/10-RESEARCH.md
@.planning/phases/10-function-calling-and-goals-migration/10-01-SUMMARY.md

@Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
@Packages/com.google.ai-embodiment/Runtime/SystemInstructionBuilder.cs
@Packages/com.google.ai-embodiment/Runtime/FunctionDeclaration.cs
@Packages/com.google.ai-embodiment/Runtime/FunctionRegistry.cs
@Packages/com.google.ai-embodiment/Runtime/GeminiEvent.cs
@Packages/com.google.ai-embodiment/Runtime/GeminiLiveClient.cs
@Packages/com.google.ai-embodiment/Runtime/GeminiLiveConfig.cs
@Packages/com.google.ai-embodiment/Runtime/PacketAssembler.cs
@Packages/com.google.ai-embodiment/Runtime/FunctionCallContext.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: PersonaSession function calling wiring and prompt-based fallback</name>
  <files>
    Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
  </files>
  <action>
    Multiple changes to PersonaSession.cs to wire the 10-01 infrastructure into the session lifecycle:

    **1. Static flag for native vs prompt-based function calling:**
    Add a public static field near the top of the class (after the SerializeField block):
    ```csharp
    /// <summary>
    /// When true, function declarations are sent as native Gemini tool JSON in the setup handshake.
    /// When false, function instructions are injected into the system prompt and the AI outputs
    /// [CALL: name {"arg": "val"}] tags parsed from transcription.
    /// Default: true (native path). Set to false if native tool calling is unreliable with audio-only models.
    /// </summary>
    public static bool UseNativeFunctionCalling = true;
    ```

    **2. Transcription buffer for prompt-based parsing:**
    Add a private field alongside the existing _ttsTextBuffer:
    ```csharp
    private readonly StringBuilder _functionCallBuffer = new StringBuilder();
    ```
    Add `using System.Text.RegularExpressions;` at the top of the file.
    Add a private static readonly Regex field:
    ```csharp
    private static readonly Regex FunctionCallPattern =
        new Regex(@"\[CALL:\s*(\w+)\s*(\{[^}]*\})\]", RegexOptions.Compiled);
    ```

    **3. RegisterFunction signature update:**
    Change `RegisterFunction(string name, FunctionHandler handler)` to:
    ```csharp
    /// <summary>
    /// Registers a function that the AI can call during conversation.
    /// Must be called before <see cref="Connect"/> -- functions are fixed for the session lifetime.
    /// </summary>
    /// <param name="name">The function name used for lookup.</param>
    /// <param name="declaration">Typed declaration describing the function's parameters for the AI.</param>
    /// <param name="handler">The delegate invoked when the AI calls this function.</param>
    public void RegisterFunction(string name, FunctionDeclaration declaration, FunctionHandler handler)
    {
        _functionRegistry.Register(name, declaration, handler);
    }
    ```
    Remove the old TODO comment.

    **4. Connect() -- pass tools to GeminiLiveConfig:**
    In Connect(), after building liveConfig and before `_client = new GeminiLiveClient(liveConfig);`, add:
    ```csharp
    // Function calling: build tool declarations for setup handshake
    if (_functionRegistry.HasRegistrations)
    {
        _functionRegistry.Freeze();
        if (UseNativeFunctionCalling)
        {
            liveConfig.ToolsJson = _functionRegistry.BuildToolsJson();
        }
    }
    ```
    Move `_functionRegistry.Freeze()` from wherever it currently is (check -- it may not be called in Connect yet; if not, the above is the only place). The registry should freeze regardless of native vs prompt-based mode.

    **5. Connect() -- inject prompt-based function instructions into system instruction:**
    In Connect(), the system instruction is currently built with `SystemInstructionBuilder.Build(_config, _goalManager)`. Change this to also include prompt-based function instructions when applicable:
    ```csharp
    var systemInstruction = SystemInstructionBuilder.Build(_config, _goalManager);

    // Prompt-based function calling: append function instructions to system prompt
    if (_functionRegistry.HasRegistrations && !UseNativeFunctionCalling)
    {
        var functionInstructions = _functionRegistry.BuildPromptInstructions();
        if (!string.IsNullOrEmpty(functionInstructions))
        {
            systemInstruction += "\n\n" + functionInstructions;
        }
    }
    ```

    **6. HandleGeminiEvent -- add FunctionCallCancellation case:**
    In the switch statement in HandleGeminiEvent, add a new case after the FunctionCall case:
    ```csharp
    case GeminiEventType.FunctionCallCancellation:
        _functionRegistry.MarkCancelled(ev.FunctionId);
        break;
    ```

    **7. HandleFunctionCallEvent -- pass FunctionId:**
    Update the existing HandleFunctionCallEvent to pass FunctionId through to PacketAssembler:
    ```csharp
    private void HandleFunctionCallEvent(GeminiEvent ev)
    {
        var args = string.IsNullOrEmpty(ev.FunctionArgsJson)
            ? new Dictionary<string, object>()
            : JObject.Parse(ev.FunctionArgsJson).ToObject<Dictionary<string, object>>();

        _packetAssembler?.AddFunctionCall(ev.FunctionName, args, ev.FunctionId);
    }
    ```
    Remove the old "Note: GeminiEvent does not currently carry a function call ID" comment.

    **8. SendFunctionResponse -- implement via GeminiLiveClient.SendToolResponse:**
    Replace the current stub implementation:
    ```csharp
    private void SendFunctionResponse(string name, IDictionary<string, object> result, string callId)
    {
        if (_client == null || !_client.IsConnected) return;
        if (string.IsNullOrEmpty(callId))
        {
            Debug.LogWarning($"PersonaSession: Cannot send function response for '{name}' -- no call ID.");
            return;
        }
        _client.SendToolResponse(callId, name, result);
    }
    ```
    Remove the old TODO comment.

    **9. HandleOutputTranscription -- prompt-based function call parsing:**
    In HandleOutputTranscription, AFTER the existing `OnOutputTranscription?.Invoke(text)` and `OnTextReceived?.Invoke(text)` calls, add prompt-based parsing:
    ```csharp
    // Prompt-based function calling: buffer text and scan for [CALL: ...] tags
    if (!UseNativeFunctionCalling && _functionRegistry.HasRegistrations)
    {
        _functionCallBuffer.Append(text);
        ParsePromptFunctionCalls();
    }
    ```
    Note: The text should still flow to OnOutputTranscription and OnTextReceived as before. The [CALL: ...] tags will appear in transcription -- this is an inherent limitation of the prompt-based approach with audio-only models (RESEARCH.md Pitfall 5). Stripping them from the event text would break the incremental transcription stream (fragments arrive word-by-word). Leave the raw text in events; the developer can filter if needed.

    **10. ParsePromptFunctionCalls helper method:**
    Add a new private method:
    ```csharp
    /// <summary>
    /// Scans the function call buffer for complete [CALL: name {...}] patterns
    /// and dispatches them as function calls. Handles transcription fragmentation
    /// by accumulating text and scanning the buffer after each append.
    /// </summary>
    private void ParsePromptFunctionCalls()
    {
        string buffer = _functionCallBuffer.ToString();
        var match = FunctionCallPattern.Match(buffer);

        while (match.Success)
        {
            string funcName = match.Groups[1].Value;
            string argsJson = match.Groups[2].Value;

            var args = new Dictionary<string, object>();
            try
            {
                args = JObject.Parse(argsJson).ToObject<Dictionary<string, object>>()
                    ?? new Dictionary<string, object>();
            }
            catch
            {
                // Garbled JSON from transcription -- use empty args
            }

            // Dispatch through PacketAssembler like native function calls
            // Prompt-based calls have no server-assigned ID, so callId is null (fire-and-forget only)
            _packetAssembler?.AddFunctionCall(funcName, args, null);

            match = match.NextMatch();
        }

        // Clear matched patterns from buffer, keep any trailing unmatched text
        var lastMatch = FunctionCallPattern.Match(buffer);
        int lastEnd = 0;
        while (lastMatch.Success)
        {
            lastEnd = lastMatch.Index + lastMatch.Length;
            lastMatch = lastMatch.NextMatch();
        }
        if (lastEnd > 0)
        {
            _functionCallBuffer.Remove(0, lastEnd);
        }

        // Prevent unbounded growth: if buffer exceeds 1000 chars with no match, trim from front
        if (_functionCallBuffer.Length > 1000)
        {
            _functionCallBuffer.Remove(0, _functionCallBuffer.Length - 500);
        }
    }
    ```

    **11. HandleInterruptedEvent -- clear function call buffer:**
    In HandleInterruptedEvent, after `_ttsTextBuffer.Clear();`, add:
    ```csharp
    _functionCallBuffer.Clear();
    ```

    **12. HandleTurnCompleteEvent -- clear function call buffer:**
    In HandleTurnCompleteEvent, after the TTS full-response block, add:
    ```csharp
    _functionCallBuffer.Clear();
    ```

    **13. Disconnect -- clear function call buffer:**
    In Disconnect(), near the `_ttsTextBuffer.Clear();` line, add:
    ```csharp
    _functionCallBuffer.Clear();
    ```

    **14. SendGoalUpdate -- finalize with proper warning:**
    Replace the current SendGoalUpdate stub:
    ```csharp
    private void SendGoalUpdate()
    {
        if (_client == null || !_client.IsConnected || State != SessionState.Connected)
            return;

        // Gemini Live API does not support mid-session system instruction updates.
        // Goals accumulate locally and will be applied at next Connect().
        Debug.Log(
            "PersonaSession: Goal updated. Mid-session system instruction updates are not supported " +
            "by the Gemini Live API. Goals will take effect on next connection.");
    }
    ```
    Note the change from LogWarning to Log -- this is expected behavior, not a warning. The user chose this design in CONTEXT.md ("silent best-effort"). Keep it as Debug.Log (informational).
  </action>
  <verify>
    Project compiles. RegisterFunction takes 3 params (name, declaration, handler). Connect() passes ToolsJson to liveConfig when native mode enabled, or appends function instructions to system prompt when prompt-based. HandleFunctionCallEvent passes FunctionId. SendFunctionResponse calls _client.SendToolResponse. FunctionCallCancellation events dispatch to MarkCancelled. HandleOutputTranscription triggers prompt-based parsing. SendGoalUpdate logs informational message.
  </verify>
  <done>
    PersonaSession fully wires the function calling pipeline: registration with declaration -> setup handshake tools -> function call dispatch with ID -> handler invocation -> toolResponse back to Gemini. Both native and prompt-based paths work. Goal updates log properly.
  </done>
</task>

<task type="auto">
  <name>Task 2: SystemInstructionBuilder prompt-based function instructions</name>
  <files>
    Packages/com.google.ai-embodiment/Runtime/SystemInstructionBuilder.cs
  </files>
  <action>
    This task adds an overload to SystemInstructionBuilder that accepts optional function instructions text for the prompt-based fallback path. However, on review, PersonaSession.Connect() already handles the concatenation directly (appending functionInstructions to the built system instruction string in Task 1, step 5). SystemInstructionBuilder does not need to know about function instructions.

    The ONLY change to SystemInstructionBuilder.cs is cosmetic cleanup: no functional changes needed. The current Build overloads (with and without GoalManager) are sufficient.

    Actually, verify there are no TODO comments in SystemInstructionBuilder.cs that reference Phase 10. If there are, remove them. If the file is clean, skip this task.

    Wait -- re-reading the file, it IS clean. No changes needed. Mark as no-op.

    ACTUALLY: Do NOT skip this task. There is one useful improvement. The Build(config, goalManager) method currently uses string concatenation. For consistency and to make the function instructions path cleaner in PersonaSession, add an overload:

    ```csharp
    /// <summary>
    /// Builds a system instruction string including conversational goals and optional
    /// function calling instructions for the prompt-based fallback path.
    /// </summary>
    /// <param name="config">The persona configuration to convert.</param>
    /// <param name="goalManager">The goal manager containing active conversational goals.</param>
    /// <param name="functionInstructions">Optional function calling instructions for prompt-based path. Null or empty to omit.</param>
    /// <returns>The formatted system instruction text.</returns>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="config"/> is null.</exception>
    public static string Build(PersonaConfig config, GoalManager goalManager, string functionInstructions)
    {
        var text = BuildInstructionText(config, goalManager);
        if (!string.IsNullOrEmpty(functionInstructions))
        {
            text += "\n\n" + functionInstructions;
        }
        return text;
    }
    ```

    Then update PersonaSession.Connect() (in Task 1) to use this overload instead of manual concatenation. The PersonaSession code becomes:
    ```csharp
    string functionInstructions = null;
    if (_functionRegistry.HasRegistrations && !UseNativeFunctionCalling)
    {
        functionInstructions = _functionRegistry.BuildPromptInstructions();
    }
    var systemInstruction = SystemInstructionBuilder.Build(_config, _goalManager, functionInstructions);
    ```

    This is cleaner: SystemInstructionBuilder owns all system instruction composition.
  </action>
  <verify>
    SystemInstructionBuilder has a 3-parameter Build overload (config, goalManager, functionInstructions). PersonaSession.Connect() uses this overload. Project compiles.
  </verify>
  <done>
    SystemInstructionBuilder composes the complete system instruction including persona, goals, and optionally prompt-based function instructions. All system instruction composition is centralized in one place.
  </done>
</task>

</tasks>

<verification>
1. PersonaSession.RegisterFunction takes (name, declaration, handler) -- matches developer-facing API from RESEARCH.md
2. Connect() builds ToolsJson from FunctionRegistry when UseNativeFunctionCalling is true
3. Connect() injects prompt-based function instructions into system instruction when UseNativeFunctionCalling is false
4. HandleGeminiEvent routes FunctionCallCancellation to FunctionRegistry.MarkCancelled
5. HandleFunctionCallEvent passes FunctionId through to PacketAssembler
6. DispatchFunctionCall checks IsCancelled before invoking handler (already implemented, just verify FunctionId flows)
7. SendFunctionResponse calls _client.SendToolResponse with callId, name, result
8. HandleOutputTranscription triggers prompt-based [CALL: ...] parsing when in prompt-based mode
9. SendGoalUpdate logs informational message about mid-session limitation
10. All buffers (_functionCallBuffer) are cleared on interruption, turn complete, and disconnect
11. Project compiles with no errors
</verification>

<success_criteria>
- MIG-04 complete: RegisterFunction declarations sent as WebSocket-native tool JSON in setup, AI-triggered function calls dispatch to handlers with correct arguments, function responses sent back via toolResponse
- MIG-05 complete: AddGoal/RemoveGoal/ReprioritizeGoal accumulate locally, applied at Connect(), mid-session logs informational message
- Both native and prompt-based function calling paths work through the same PersonaSession API
- UseNativeFunctionCalling static flag lets developers switch paths without code changes
- No regressions in existing session lifecycle, audio routing, TTS, or transcription
</success_criteria>

<output>
After completion, create `.planning/phases/10-function-calling-and-goals-migration/10-02-SUMMARY.md`
</output>
