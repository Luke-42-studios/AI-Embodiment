---
phase: 10-function-calling-and-goals-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/FunctionDeclaration.cs
  - Packages/com.google.ai-embodiment/Runtime/FunctionRegistry.cs
  - Packages/com.google.ai-embodiment/Runtime/GeminiEvent.cs
  - Packages/com.google.ai-embodiment/Runtime/GeminiLiveConfig.cs
  - Packages/com.google.ai-embodiment/Runtime/GeminiLiveClient.cs
autonomous: true

must_haves:
  truths:
    - "Developers register functions with typed declarations (name, description, typed parameters) before Connect()"
    - "Tool declarations are sent as JSON in the WebSocket setup handshake when native mode is enabled"
    - "Function call IDs from the server are captured and flow through events to enable response correlation"
    - "Function responses can be sent back to Gemini via toolResponse WebSocket messages"
    - "Tool call cancellations from the server are parsed and enqueued as events"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/FunctionDeclaration.cs"
      provides: "Typed builder for function schemas with flat-primitive parameters"
      contains: "class FunctionDeclaration"
    - path: "Packages/com.google.ai-embodiment/Runtime/FunctionRegistry.cs"
      provides: "Declaration storage, BuildToolsJson(), BuildPromptInstructions()"
      contains: "BuildToolsJson"
    - path: "Packages/com.google.ai-embodiment/Runtime/GeminiEvent.cs"
      provides: "FunctionId field and FunctionCallCancellation event type"
      contains: "FunctionId"
    - path: "Packages/com.google.ai-embodiment/Runtime/GeminiLiveConfig.cs"
      provides: "ToolsJson field for passing tool declarations to setup"
      contains: "ToolsJson"
    - path: "Packages/com.google.ai-embodiment/Runtime/GeminiLiveClient.cs"
      provides: "Tools in setup message, SendToolResponse method, toolCallCancellation parsing"
      contains: "SendToolResponse"
  key_links:
    - from: "FunctionDeclaration.cs"
      to: "FunctionRegistry.cs"
      via: "Register stores declaration, BuildToolsJson iterates declarations"
      pattern: "entry\\.Value\\.Declaration\\.ToToolJson"
    - from: "FunctionRegistry.cs"
      to: "GeminiLiveClient.cs"
      via: "GeminiLiveConfig.ToolsJson carries declarations to setup message"
      pattern: "ToolsJson"
    - from: "GeminiLiveClient.cs"
      to: "GeminiEvent.cs"
      via: "toolCall parsing captures FunctionId, toolCallCancellation enqueues events"
      pattern: "FunctionId.*fc\\[\"id\"\\]"
---

<objective>
Build the function calling infrastructure: typed FunctionDeclaration builder, FunctionRegistry declaration support with dual-path output (native JSON + prompt-based text), transport-level changes (FunctionId on events, tools in setup handshake, SendToolResponse, toolCallCancellation parsing).

Purpose: Provides all the data types and transport plumbing that Plan 10-02 wires into PersonaSession.
Output: FunctionDeclaration.cs (new), updated FunctionRegistry, GeminiEvent, GeminiLiveConfig, GeminiLiveClient.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-function-calling-and-goals-migration/10-CONTEXT.md
@.planning/phases/10-function-calling-and-goals-migration/10-RESEARCH.md

@Packages/com.google.ai-embodiment/Runtime/FunctionDeclaration.cs
@Packages/com.google.ai-embodiment/Runtime/FunctionRegistry.cs
@Packages/com.google.ai-embodiment/Runtime/GeminiEvent.cs
@Packages/com.google.ai-embodiment/Runtime/GeminiLiveConfig.cs
@Packages/com.google.ai-embodiment/Runtime/GeminiLiveClient.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: FunctionDeclaration builder and FunctionRegistry upgrade</name>
  <files>
    Packages/com.google.ai-embodiment/Runtime/FunctionDeclaration.cs
    Packages/com.google.ai-embodiment/Runtime/FunctionRegistry.cs
  </files>
  <action>
    **FunctionDeclaration.cs (NEW):** Create a typed builder class in the AIEmbodiment namespace. Per CONTEXT.md: flat primitive parameters only (string, int, float, bool, enum). No nested objects.

    Structure:
    - Constructor: `FunctionDeclaration(string name, string description)`
    - Read-only properties: `Name`, `Description`
    - Private `List<ParameterDef>` storing parameter definitions
    - Private `ParameterDef` inner class/struct with fields: `Name`, `Description`, `Type` (string like "STRING", "INTEGER", "NUMBER", "BOOLEAN"), `Required` (bool), `EnumValues` (string[] or null)
    - Fluent builder methods returning `this`:
      - `AddString(string name, string description, bool required = true)`
      - `AddInt(string name, string description, bool required = true)`
      - `AddFloat(string name, string description, bool required = true)`
      - `AddBool(string name, string description, bool required = true)`
      - `AddEnum(string name, string description, string[] values, bool required = true)`
    - `JObject ToToolJson()` -- builds Gemini API JSON: `{"name": "...", "description": "...", "parameters": {"type": "OBJECT", "properties": {...}, "required": [...]}}`. Each parameter becomes a property with `"type"` (STRING/INTEGER/NUMBER/BOOLEAN), `"description"`, and optionally `"enum"`. Only `required: true` params appear in the `"required"` array. If zero parameters, omit the `"parameters"` key entirely.
    - `string ToPromptText()` -- builds human-readable text: `"- name(param1: type, param2: type [val1|val2]) - description"`. Types: "string", "int", "float", "bool". Enum values shown in brackets.

    Use `using Newtonsoft.Json.Linq;` for JObject/JArray. Follow existing codebase XML doc comment style.

    **FunctionRegistry.cs (MODIFY):** Upgrade to store declarations alongside handlers.

    Changes:
    1. Add a private inner class `RegistryEntry` with `FunctionHandler Handler` and `FunctionDeclaration Declaration` fields
    2. Change `_entries` from `Dictionary<string, FunctionHandler>` to `Dictionary<string, RegistryEntry>`
    3. Change `Register` signature to `Register(string name, FunctionDeclaration declaration, FunctionHandler handler)` -- declaration is required (not null). Remove the old TODO comment.
    4. Update `TryGetHandler` to extract handler from RegistryEntry
    5. Add `BuildToolsJson()` returning `JArray`: wraps all declarations in `[{"functionDeclarations": [...]}]` format. Returns null if no registrations.
    6. Add `BuildPromptInstructions()` returning `string`: builds the prompt-based fallback text per RESEARCH.md Pattern 5. Format:
       ```
       AVAILABLE FUNCTIONS:
       When you want to call a function, output EXACTLY this format:
       [CALL: function_name {"param": "value"}]

       Functions:
       - play_emote(emote_name: string [wave|bow|laugh]) - Play a character animation
       ...

       IMPORTANT: Output the [CALL: ...] tag exactly. Do not narrate it.
       ```
       Returns null if no registrations.

    Add `using Newtonsoft.Json.Linq;` and `using System.Text;` to FunctionRegistry.
  </action>
  <verify>
    Project compiles: run `dotnet build` or verify no syntax errors by reading the files and checking all types resolve. FunctionDeclaration has all 5 Add methods + ToToolJson + ToPromptText. FunctionRegistry.Register takes 3 params, BuildToolsJson returns JArray, BuildPromptInstructions returns string.
  </verify>
  <done>
    FunctionDeclaration builder produces correct Gemini API JSON and prompt text. FunctionRegistry stores declarations alongside handlers and exposes both native and prompt-based output methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: GeminiEvent, GeminiLiveConfig, and GeminiLiveClient transport upgrades</name>
  <files>
    Packages/com.google.ai-embodiment/Runtime/GeminiEvent.cs
    Packages/com.google.ai-embodiment/Runtime/GeminiLiveConfig.cs
    Packages/com.google.ai-embodiment/Runtime/GeminiLiveClient.cs
  </files>
  <action>
    **GeminiEvent.cs (MODIFY):**
    1. Add `public string FunctionId;` field to the struct (after FunctionArgsJson)
    2. Add `FunctionCallCancellation` to the GeminiEventType enum (after FunctionCall, before Connected)

    **GeminiLiveConfig.cs (MODIFY):**
    1. Add `using Newtonsoft.Json.Linq;` at top
    2. Add `public JArray ToolsJson;` field (after AudioOutputSampleRate). Default is null (no tools).

    **GeminiLiveClient.cs (MODIFY):** Three changes:

    1. **Setup message tools injection (SendSetupMessage):** After the systemInstruction block and before `var setup = new JObject { ["setup"] = setupInner };`, add:
       ```csharp
       // Tools (function declarations for native function calling)
       if (_config.ToolsJson != null && _config.ToolsJson.Count > 0)
       {
           setupInner["tools"] = _config.ToolsJson;
       }
       ```

    2. **FunctionId capture in toolCall parsing (HandleJsonMessage):** In the existing toolCall parsing block (around line 433), add `FunctionId = fc["id"]?.ToString()` to the GeminiEvent construction:
       ```csharp
       Enqueue(new GeminiEvent
       {
           Type = GeminiEventType.FunctionCall,
           FunctionName = name,
           FunctionArgsJson = args,
           FunctionId = fc["id"]?.ToString()
       });
       ```

    3. **toolCallCancellation parsing (HandleJsonMessage):** Replace the `// toolCallCancellation -- Phase 10 will add full handling; skip for now` comment with actual parsing:
       ```csharp
       // toolCallCancellation -- cancel pending function calls (user interruption)
       var toolCallCancellation = msg["toolCallCancellation"] as JObject;
       if (toolCallCancellation != null)
       {
           var ids = toolCallCancellation["ids"] as JArray;
           if (ids != null)
           {
               foreach (var id in ids)
               {
                   Enqueue(new GeminiEvent
                   {
                       Type = GeminiEventType.FunctionCallCancellation,
                       FunctionId = id.ToString()
                   });
               }
           }
       }
       ```

    4. **SendToolResponse method:** Add a new public method after SendText:
       ```csharp
       /// <summary>Send a tool response back to Gemini for function call correlation.</summary>
       public void SendToolResponse(string callId, string functionName, IDictionary<string, object> response)
       {
           if (!IsConnected || string.IsNullOrEmpty(callId)) return;

           var responseObj = response != null ? JObject.FromObject(response) : new JObject();
           var payload = new JObject
           {
               ["toolResponse"] = new JObject
               {
                   ["functionResponses"] = new JArray
                   {
                       new JObject
                       {
                           ["id"] = callId,
                           ["name"] = functionName,
                           ["response"] = responseObj
                       }
                   }
               }
           };
           _ = SendJsonAsync(payload);
       }
       ```
       Add `using System.Collections.Generic;` to GeminiLiveClient.cs if not already present (it is not -- check and add).
  </action>
  <verify>
    Project compiles. GeminiEvent has FunctionId field and FunctionCallCancellation enum value. GeminiLiveConfig has ToolsJson field. GeminiLiveClient has SendToolResponse method, toolCallCancellation parsing, FunctionId capture in toolCall, and tools in setup message.
  </verify>
  <done>
    All transport-level changes are in place: function call IDs flow through events, tool declarations are included in setup handshake, tool responses can be sent back, and cancellations are parsed and enqueued.
  </done>
</task>

</tasks>

<verification>
1. All files compile without errors (no Unity editor needed -- syntax and type resolution check)
2. GeminiEvent.FunctionId field exists
3. GeminiEventType.FunctionCallCancellation enum value exists
4. FunctionDeclaration builder has AddString/AddInt/AddFloat/AddBool/AddEnum + ToToolJson + ToPromptText
5. FunctionRegistry.Register takes (name, declaration, handler)
6. FunctionRegistry.BuildToolsJson returns JArray with correct Gemini API format
7. FunctionRegistry.BuildPromptInstructions returns formatted prompt text
8. GeminiLiveConfig.ToolsJson field exists
9. GeminiLiveClient.SendSetupMessage includes tools when ToolsJson is set
10. GeminiLiveClient.SendToolResponse method exists with correct toolResponse JSON format
11. GeminiLiveClient.HandleJsonMessage captures FunctionId from toolCall and parses toolCallCancellation
</verification>

<success_criteria>
- FunctionDeclaration builder produces valid Gemini API JSON for tool declarations
- FunctionRegistry stores declarations and outputs both native JSON and prompt text
- GeminiEvent carries FunctionId for response correlation
- GeminiLiveClient sends tools in setup, captures function call IDs, sends tool responses, and handles cancellations
- All existing functionality preserved (no regressions in audio, transcription, turn lifecycle)
</success_criteria>

<output>
After completion, create `.planning/phases/10-function-calling-and-goals-migration/10-01-SUMMARY.md`
</output>
