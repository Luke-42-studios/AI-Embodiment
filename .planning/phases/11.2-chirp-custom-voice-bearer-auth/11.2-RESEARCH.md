# Phase 11.2: Chirp Custom Voice Bearer Auth - Research

**Researched:** 2026-02-17
**Domain:** Google Cloud TTS v1beta1 REST API, OAuth2 Service Account JWT authentication, Unity C# cryptography
**Confidence:** HIGH

## Summary

This phase replaces the current API key authentication (`x-goog-api-key` header) in `ChirpTTSClient` with OAuth2 bearer token authentication (`Authorization: Bearer` header) to enable Chirp 3 instant custom voice cloning via the v1beta1 endpoint.

The existing `ChirpTTSClient` already handles the `voiceClone.voiceCloningKey` request body structure correctly. The changes needed are: (1) a new credential provider class that loads a service account JSON key, signs a JWT with RSA SHA-256, exchanges it for an access token at `oauth2.googleapis.com/token`, and caches/refreshes the token; (2) switching the HTTP endpoint from v1 to v1beta1; (3) replacing the `x-goog-api-key` header with `Authorization: Bearer {token}` and adding `x-goog-user-project` header; (4) updating AIEmbodimentSettings to hold a service account JSON key file path instead of (or in addition to) the API key.

**Primary recommendation:** Build a standalone `GoogleServiceAccountAuth` class (plain C#, not MonoBehaviour) that handles JWT signing and token exchange using only `System.Security.Cryptography` and `UnityWebRequest`. Load the service account JSON from a configurable path at runtime. No external dependencies required.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| System.Security.Cryptography | .NET Std 2.1 | RSA SHA-256 JWT signing | Built into Unity 6 runtime, no external dependency |
| UnityWebRequest | Unity 6 | HTTP POST for token exchange and TTS requests | Already used by ChirpTTSClient, must stay on main thread |
| Newtonsoft.Json | 3.2.1 (UPM) | Parse service account JSON, build JWT claims | Already a project dependency |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| System.Text.Encoding | .NET Std 2.1 | UTF-8 / Base64url encoding for JWT | Always -- part of JWT construction |
| System.BitConverter | .NET Std 2.1 | Unix timestamp calculation | Always -- JWT iat/exp claims |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Manual JWT signing | Google.Apis.Auth NuGet | Adds large dependency tree; NuGet in Unity is fragile; only need 1 function (sign JWT) |
| System.Security.Cryptography | BouncyCastle | Cross-platform PKCS8 parsing guaranteed, but adds ~2MB dependency for one operation |
| Manual token exchange | Google.Apis.Auth ServiceAccountCredential | Handles token caching internally, but pulls in entire Google SDK stack |

**Installation:**
No new packages needed. All required APIs are in .NET Standard 2.1 (shipped with Unity 6) and existing `com.unity.nuget.newtonsoft-json`.

## Architecture Patterns

### Recommended Project Structure
```
Runtime/
├── ChirpTTSClient.cs               # MODIFY: accept auth provider, switch endpoint
├── GoogleServiceAccountAuth.cs      # NEW: JWT signing + token exchange + caching
├── AIEmbodimentSettings.cs          # MODIFY: add service account JSON path field
└── ITTSProvider.cs                  # UNCHANGED
Editor/
├── AIEmbodimentSettingsEditor.cs    # MODIFY: add service account UI
```

### Pattern 1: Credential Provider (Separation of Auth from HTTP Client)
**What:** A standalone class that owns the service account credential lifecycle (load key, sign JWT, exchange token, cache, refresh). ChirpTTSClient calls `await auth.GetAccessTokenAsync()` before each request.
**When to use:** Always -- separates auth concern from TTS concern.
**Example:**
```csharp
// Source: Google OAuth2 service account spec + project conventions
public class GoogleServiceAccountAuth : IDisposable
{
    private readonly string _clientEmail;
    private readonly string _projectId;
    private readonly RSA _rsa;
    private string _cachedToken;
    private DateTime _tokenExpiry;

    // Load from service account JSON
    public GoogleServiceAccountAuth(string serviceAccountJson)
    {
        var json = JObject.Parse(serviceAccountJson);
        _clientEmail = json["client_email"].ToString();
        _projectId = json["project_id"].ToString();
        string privateKeyPem = json["private_key"].ToString();
        _rsa = RSA.Create();
        // Strip PEM headers, decode base64, import PKCS8
        byte[] keyBytes = Convert.FromBase64String(
            privateKeyPem
                .Replace("-----BEGIN PRIVATE KEY-----", "")
                .Replace("-----END PRIVATE KEY-----", "")
                .Replace("\n", ""));
        _rsa.ImportPkcs8PrivateKey(keyBytes, out _);
    }

    public string ProjectId => _projectId;

    public async Awaitable<string> GetAccessTokenAsync()
    {
        // Return cached token if still valid (with 5-min buffer)
        if (_cachedToken != null && DateTime.UtcNow < _tokenExpiry)
            return _cachedToken;

        string jwt = BuildSignedJwt();
        _cachedToken = await ExchangeJwtForToken(jwt);
        return _cachedToken;
    }

    private string BuildSignedJwt()
    {
        long iat = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
        long exp = iat + 3600; // 1 hour

        string header = Base64UrlEncode(
            Encoding.UTF8.GetBytes("{\"alg\":\"RS256\",\"typ\":\"JWT\"}"));
        string claims = Base64UrlEncode(
            Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(new {
                iss = _clientEmail,
                scope = "https://www.googleapis.com/auth/cloud-platform",
                aud = "https://oauth2.googleapis.com/token",
                iat = iat,
                exp = exp
            })));

        string input = header + "." + claims;
        byte[] signature = _rsa.SignData(
            Encoding.UTF8.GetBytes(input),
            HashAlgorithmName.SHA256,
            RSASignaturePadding.Pkcs1);

        return input + "." + Base64UrlEncode(signature);
    }

    private static string Base64UrlEncode(byte[] data)
    {
        return Convert.ToBase64String(data)
            .TrimEnd('=')
            .Replace('+', '-')
            .Replace('/', '_');
    }
}
```

### Pattern 2: Token Refresh with Safety Margin
**What:** Cache the access token for its full 3600-second lifetime but refresh 5 minutes before expiry to avoid race conditions where a request starts with a valid token that expires mid-flight.
**When to use:** Always -- tokens expire after exactly 1 hour.
**Example:**
```csharp
// Source: Google OAuth2 spec (token lifetime = 3600s)
private const int TOKEN_REFRESH_MARGIN_SECONDS = 300; // 5 minutes

public async Awaitable<string> GetAccessTokenAsync()
{
    if (_cachedToken != null
        && DateTime.UtcNow.AddSeconds(TOKEN_REFRESH_MARGIN_SECONDS) < _tokenExpiry)
        return _cachedToken;

    // Token expired or about to expire -- refresh
    string jwt = BuildSignedJwt();
    _cachedToken = await ExchangeJwtForToken(jwt);
    return _cachedToken;
}
```

### Pattern 3: Dual Endpoint Support (v1 for standard, v1beta1 for custom)
**What:** Both standard Chirp voices and custom/cloned voices can work through bearer auth on v1beta1. Use v1beta1 for all requests when using bearer auth.
**When to use:** When bearer auth is configured (service account present). The v1beta1 endpoint is a superset of v1.
**Example:**
```csharp
// Source: Google Cloud TTS REST API reference
private const string TTS_ENDPOINT_V1 = "https://texttospeech.googleapis.com/v1/text:synthesize";
private const string TTS_ENDPOINT_V1BETA1 = "https://texttospeech.googleapis.com/v1beta1/text:synthesize";

// Use v1beta1 for bearer auth (supports both standard and custom voices)
private string GetEndpoint() =>
    _auth != null ? TTS_ENDPOINT_V1BETA1 : TTS_ENDPOINT_V1;
```

### Anti-Patterns to Avoid
- **Embedding service account JSON in the ScriptableObject asset:** The JSON key contains a private key -- it must never be serialized into a Unity asset that could be included in builds. Load from file path at runtime.
- **Refreshing token on every request:** Defeats caching. Token exchange requires an HTTP round-trip. Cache aggressively with a safety margin.
- **Using `async void` for token refresh:** Exceptions vanish. The auth method should be `async Awaitable<string>` so callers can catch failures.
- **Blocking the main thread for crypto:** `RSA.SignData` is fast (~1ms for 2048-bit keys). Token exchange via `UnityWebRequest` is already async. No blocking risk.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Base64url encoding | Custom bit manipulation | `Convert.ToBase64String` + char replacement | Standard JWT spec encoding; 3 lines of code |
| JSON web token structure | Custom string concatenation | Newtonsoft.Json for claims + manual header.claims.signature assembly | Claims need proper JSON escaping |
| RSA SHA-256 signing | Manual crypto operations | `RSA.Create()` + `ImportPkcs8PrivateKey` + `SignData` | .NET Standard 2.1 has everything needed |
| Service account JSON parsing | Manual string parsing | `JObject.Parse` (Newtonsoft.Json) | Already a project dependency; handles escaping in private_key field |
| Unix timestamps | Manual DateTime math | `DateTimeOffset.UtcNow.ToUnixTimeSeconds()` | Built-in .NET Standard 2.1 API |

**Key insight:** The entire JWT-sign-and-exchange flow is ~80 lines of C# using only .NET Standard 2.1 built-ins and Newtonsoft.Json. No external auth library needed.

## Common Pitfalls

### Pitfall 1: ImportPkcs8PrivateKey May Fail on Non-Desktop Platforms
**What goes wrong:** `RSA.ImportPkcs8PrivateKey` throws "Unable to import PKCS#8 private key with the current runtime" on Android (IL2CPP) in Unity 6.
**Why it happens:** Unity 6 still uses Mono (not CoreCLR). Mono's implementation of certain .NET Standard 2.1 crypto APIs is incomplete on mobile platforms.
**How to avoid:** Since success criterion 5 says credentials must NOT be shipped in player builds, this is editor-only code. The Unity Editor runs on desktop Mono where `ImportPkcs8PrivateKey` works. If future phases need mobile auth, use a server-side token proxy or BouncyCastle.
**Warning signs:** Build errors on mobile targets mentioning PKCS#8 or cryptography.

### Pitfall 2: Base64 vs Base64url Encoding
**What goes wrong:** JWT uses Base64url encoding (RFC 4648 section 5), not standard Base64. Using standard Base64 produces invalid JWTs that Google's token endpoint rejects with 400 Bad Request.
**Why it happens:** `Convert.ToBase64String` produces standard Base64 with `+`, `/`, and `=` padding.
**How to avoid:** Always post-process: replace `+` with `-`, `/` with `_`, trim trailing `=`.
**Warning signs:** 400 error from `oauth2.googleapis.com/token` with "Invalid JWT" message.

### Pitfall 3: JWT `aud` Claim Must Match Token Endpoint
**What goes wrong:** Using the wrong `aud` value causes token exchange to fail silently or return an error.
**Why it happens:** Google expects `aud` to be `https://oauth2.googleapis.com/token` (the token endpoint itself), not the TTS API URL.
**How to avoid:** Hard-code `aud` to `https://oauth2.googleapis.com/token`.
**Warning signs:** "Invalid JWT: Token must be a short-lived token" or "invalid_grant" errors.

### Pitfall 4: Token Exchange Content-Type Must Be Form-Encoded
**What goes wrong:** Sending the token exchange request as JSON causes 400 errors.
**Why it happens:** Google's token endpoint expects `application/x-www-form-urlencoded`, not JSON.
**How to avoid:** Use `WWWForm` or manually URL-encode the body: `grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion={jwt}`.
**Warning signs:** 400 error from token endpoint despite valid JWT.

### Pitfall 5: Forgetting `x-goog-user-project` Header
**What goes wrong:** TTS requests succeed but billing goes to the wrong project or fails with permission errors.
**Why it happens:** Bearer token auth identifies the service account but not necessarily the billing project.
**How to avoid:** Include `x-goog-user-project: {projectId}` header on all TTS requests. Parse `project_id` from the service account JSON.
**Warning signs:** 403 errors mentioning project or billing.

### Pitfall 6: Private Key Newlines in JSON
**What goes wrong:** The `private_key` field in service account JSON contains literal `\n` escape sequences that must be converted to actual newlines before PEM parsing.
**Why it happens:** JSON serialization escapes newlines.
**How to avoid:** Newtonsoft.Json handles `\n` unescaping automatically when you use `json["private_key"].ToString()`. No manual replacement needed.
**Warning signs:** "No PEM-encoded data found" or "Invalid key format" when importing.

### Pitfall 7: Custom Voices Do Not Support SSML
**What goes wrong:** Sending SSML-wrapped text to a custom/cloned voice causes synthesis errors.
**Why it happens:** Google's custom voice pipeline does not process SSML tags.
**How to avoid:** The existing ChirpTTSClient already handles this correctly -- it uses plain `text` for custom voices and `ssml` for standard voices. Preserve this logic.
**Warning signs:** Already handled in current code.

## Code Examples

Verified patterns from official sources:

### Token Exchange HTTP Request
```csharp
// Source: https://developers.google.com/identity/protocols/oauth2/service-account
private async Awaitable<string> ExchangeJwtForToken(string jwt)
{
    var form = new WWWForm();
    form.AddField("grant_type", "urn:ietf:params:oauth:grant-type:jwt-bearer");
    form.AddField("assertion", jwt);

    using var request = UnityWebRequest.Post(
        "https://oauth2.googleapis.com/token", form);

    await request.SendWebRequest();

    if (request.result != UnityWebRequest.Result.Success)
        throw new Exception($"Token exchange failed: {request.error}\n{request.downloadHandler?.text}");

    var response = JObject.Parse(request.downloadHandler.text);
    string accessToken = response["access_token"].ToString();
    int expiresIn = response["expires_in"].Value<int>();

    _tokenExpiry = DateTime.UtcNow.AddSeconds(expiresIn);
    return accessToken;
}
```

### Bearer Auth TTS Request (Modified ChirpTTSClient)
```csharp
// Source: https://docs.cloud.google.com/text-to-speech/docs/reference/rest/v1beta1/text/synthesize
// Replaces the current x-goog-api-key header approach
string endpoint = _auth != null ? TTS_ENDPOINT_V1BETA1 : TTS_ENDPOINT_V1;

using var request = new UnityWebRequest(endpoint, "POST");
request.uploadHandler = new UploadHandlerRaw(bodyBytes);
request.downloadHandler = new DownloadHandlerBuffer();
request.SetRequestHeader("Content-Type", "application/json; charset=utf-8");

if (_auth != null)
{
    string token = await _auth.GetAccessTokenAsync();
    request.SetRequestHeader("Authorization", "Bearer " + token);
    request.SetRequestHeader("x-goog-user-project", _auth.ProjectId);
}
else
{
    request.SetRequestHeader("x-goog-api-key", _apiKey);
}
```

### Service Account JSON Structure (Reference)
```json
{
  "type": "service_account",
  "project_id": "my-project-123",
  "private_key_id": "key-id-here",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvgIBA...\n-----END PRIVATE KEY-----\n",
  "client_email": "tts-service@my-project-123.iam.gserviceaccount.com",
  "client_id": "123456789",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token"
}
```

### v1beta1 Voice Clone Request Body (Already Correct in Existing Code)
```json
{
  "input": { "text": "Hello world" },
  "voice": {
    "languageCode": "en-US",
    "voiceClone": {
      "voiceCloningKey": "base64-encoded-key"
    }
  },
  "audioConfig": {
    "audioEncoding": "LINEAR16",
    "sampleRateHertz": 24000
  }
}
```

### Loading Credentials Securely in AIEmbodimentSettings
```csharp
// Source: Project conventions (AIEmbodimentSettings pattern)
// Service account JSON path -- editor-only, not serialized into builds
[SerializeField] private string _serviceAccountJsonPath = "";

/// <summary>
/// Reads the service account JSON from the configured file path.
/// Returns null if path is empty or file does not exist.
/// Editor-only: service account files should never be in Resources or StreamingAssets.
/// </summary>
public string LoadServiceAccountJson()
{
    if (string.IsNullOrEmpty(_serviceAccountJsonPath))
        return null;
    if (!System.IO.File.Exists(_serviceAccountJsonPath))
    {
        Debug.LogError($"Service account JSON not found: {_serviceAccountJsonPath}");
        return null;
    }
    return System.IO.File.ReadAllText(_serviceAccountJsonPath);
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| API key via `x-goog-api-key` header | Bearer token via `Authorization: Bearer` | Required for v1beta1 voice cloning | Voice cloning only works with bearer auth |
| v1 endpoint for all TTS | v1beta1 for custom voices | v1beta1 is the only endpoint supporting voiceClone | Must use v1beta1 for custom voice requests |
| Google.Apis.Auth library for .NET auth | Manual JWT signing (for Unity) | N/A -- manual approach avoids Unity NuGet issues | ~80 lines replaces heavy dependency |
| P12 certificate files | JSON key files | Google recommends JSON format since ~2020 | JSON is the standard format for new service accounts |

**Deprecated/outdated:**
- P12 key files: Still supported but JSON is recommended for new service accounts
- `accounts.google.com/o/oauth2/token` endpoint: Use `oauth2.googleapis.com/token` instead (same service, canonical URL)

## Open Questions

Things that couldn't be fully resolved:

1. **RSA.ImportPkcs8PrivateKey reliability across all Unity 6 desktop platforms**
   - What we know: Works in Unity Editor on desktop (Windows/Mac/Linux with Mono). Fails on Android IL2CPP.
   - What's unclear: Whether it works in standalone desktop builds with IL2CPP backend.
   - Recommendation: Since credentials are editor-only (success criterion 5), this is not a blocker. If standalone builds ever need auth, add a BouncyCastle fallback or server-side token proxy.

2. **Whether v1beta1 endpoint accepts API key auth for standard (non-custom) voices**
   - What we know: v1beta1 synthesis endpoint requires OAuth scope `https://www.googleapis.com/auth/cloud-platform`. All official examples use bearer auth.
   - What's unclear: Whether `x-goog-api-key` works on v1beta1 (it works on v1).
   - Recommendation: When service account is configured, use bearer auth for ALL requests (both standard and custom voices). When only API key is available, continue using v1 endpoint with `x-goog-api-key`. This matches success criterion 4.

3. **Voice cloning allow-listing requirement**
   - What we know: Google documentation states "access to this voice cloning capability is restricted to allow-listed users" enforced at the project level.
   - What's unclear: Whether allow-listing is automatic with service account setup or requires a separate application.
   - Recommendation: Document this prerequisite clearly. Not a code concern.

## Sources

### Primary (HIGH confidence)
- Google Cloud TTS v1beta1 REST API reference -- endpoint URL, request format, OAuth scope requirement (`https://www.googleapis.com/auth/cloud-platform`)
  - https://docs.cloud.google.com/text-to-speech/docs/reference/rest/v1beta1/text/synthesize
- Google OAuth2 Service Account JWT spec -- JWT structure, token exchange protocol, signing requirements
  - https://developers.google.com/identity/protocols/oauth2/service-account
- Google Cloud TTS Chirp 3 instant custom voice documentation -- voiceClone request format, bearer auth requirement
  - https://docs.cloud.google.com/text-to-speech/docs/chirp3-instant-custom-voice
- Google official Colab notebook -- confirmed v1beta1 + bearer auth + voiceClone JSON structure
  - https://colab.research.google.com/github/GoogleCloudPlatform/generative-ai/blob/main/audio/speech/getting-started/get_started_with_chirp3_instant_custom_voice.ipynb
- Google Cloud TTS OAuth scopes -- CloudPlatform scope for TTS
  - https://googleapis.dev/dotnet/Google.Apis.Texttospeech.v1/latest/api/Google.Apis.Texttospeech.v1.TexttospeechService.Scope.html

### Secondary (MEDIUM confidence)
- Unity 6 RSA ImportPkcs8PrivateKey issue on Android -- confirmed failure on Quest/IL2CPP
  - https://discuss.google.dev/t/unity-6-speech-to-text-v2-rsa-key-import-error/291479
- .NET Standard 2.1 RSA API surface -- ImportPkcs8PrivateKey, SignData availability
  - https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importpkcs8privatekey

### Tertiary (LOW confidence)
- Desktop standalone IL2CPP compatibility with ImportPkcs8PrivateKey -- no direct verification found
- BouncyCastle as fallback for PKCS8 parsing in Unity -- community examples only

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- uses only .NET Standard 2.1 built-ins and existing Newtonsoft.Json dependency
- Architecture: HIGH -- credential provider pattern is well-established; existing ChirpTTSClient structure cleanly supports extension
- API format: HIGH -- verified against official Google REST API reference and Colab examples
- OAuth flow: HIGH -- Google's service account JWT spec is thoroughly documented
- Pitfalls: HIGH -- crypto API surface, Base64url encoding, content-type requirements are well-documented
- Platform compatibility: MEDIUM -- desktop editor confirmed working, mobile/IL2CPP uncertain but out of scope per success criteria

**Research date:** 2026-02-17
**Valid until:** 2026-03-17 (Google Cloud APIs are stable; Unity crypto support may change with CoreCLR migration)
