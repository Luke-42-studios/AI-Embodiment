---
phase: 11.2-chirp-custom-voice-bearer-auth
plan: 02
type: execute
wave: 2
depends_on: ["11.2-01"]
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/ChirpTTSClient.cs
  - Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
autonomous: true

must_haves:
  truths:
    - "ChirpTTSClient uses Authorization: Bearer header with auto-refreshed OAuth2 token when a GoogleServiceAccountAuth is provided"
    - "ChirpTTSClient targets the v1beta1 endpoint when using bearer auth for both standard and custom voices"
    - "ChirpTTSClient falls back to API key auth on the v1 endpoint when no auth provider is given"
    - "ChirpTTSClient includes x-goog-user-project header when using bearer auth"
    - "PersonaSession creates GoogleServiceAccountAuth from AIEmbodimentSettings.LoadServiceAccountJson() and passes it to ChirpTTSClient when service account is configured"
    - "PersonaSession disposes GoogleServiceAccountAuth on disconnect and destroy"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/ChirpTTSClient.cs"
      provides: "Dual-auth TTS client (API key or bearer token) with v1/v1beta1 endpoint switching"
      contains: "v1beta1"
    - path: "Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs"
      provides: "Auth-aware TTS provider instantiation with service account lifecycle management"
      contains: "GoogleServiceAccountAuth"
  key_links:
    - from: "PersonaSession.Connect"
      to: "GoogleServiceAccountAuth constructor"
      via: "AIEmbodimentSettings.LoadServiceAccountJson() feeds JSON to auth constructor"
      pattern: "new GoogleServiceAccountAuth"
    - from: "ChirpTTSClient.SynthesizeAsync"
      to: "GoogleServiceAccountAuth.GetAccessTokenAsync"
      via: "await _auth.GetAccessTokenAsync() before each HTTP request"
      pattern: "_auth\\.GetAccessTokenAsync"
    - from: "ChirpTTSClient.SynthesizeAsync"
      to: "v1beta1 endpoint"
      via: "Endpoint selection based on _auth != null"
      pattern: "v1beta1/text:synthesize"
    - from: "PersonaSession.Disconnect"
      to: "GoogleServiceAccountAuth.Dispose"
      via: "Dispose auth in disconnect and OnDestroy"
      pattern: "_serviceAuth.*Dispose"
---

<objective>
Wire GoogleServiceAccountAuth into ChirpTTSClient and PersonaSession for bearer token authentication on the v1beta1 endpoint.

Purpose: Enables Chirp custom voice cloning by switching from API key auth (v1 endpoint) to OAuth2 bearer token auth (v1beta1 endpoint) when a service account is configured. Standard voices also benefit from bearer auth. Preserves backward compatibility when only an API key is available.

Output: Modified ChirpTTSClient with dual-auth support, modified PersonaSession with service account lifecycle management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11.2-chirp-custom-voice-bearer-auth/11.2-RESEARCH.md
@.planning/phases/11.2-chirp-custom-voice-bearer-auth/11.2-01-SUMMARY.md

@Packages/com.google.ai-embodiment/Runtime/ChirpTTSClient.cs
@Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
@Packages/com.google.ai-embodiment/Runtime/AIEmbodimentSettings.cs
@Packages/com.google.ai-embodiment/Runtime/GoogleServiceAccountAuth.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bearer token auth and v1beta1 endpoint to ChirpTTSClient</name>
  <files>Packages/com.google.ai-embodiment/Runtime/ChirpTTSClient.cs</files>
  <action>
Modify ChirpTTSClient to support dual authentication paths: API key (existing v1) and bearer token (new v1beta1).

**1. Add endpoint constants** -- replace the single `TTS_ENDPOINT` with two:
```csharp
private const string TTS_ENDPOINT_V1 = "https://texttospeech.googleapis.com/v1/text:synthesize";
private const string TTS_ENDPOINT_V1BETA1 = "https://texttospeech.googleapis.com/v1beta1/text:synthesize";
```

**2. Add auth field** -- add `private readonly GoogleServiceAccountAuth _auth;` alongside existing `_apiKey` field.

**3. Add second constructor overload** that accepts GoogleServiceAccountAuth instead of API key:
```csharp
public ChirpTTSClient(GoogleServiceAccountAuth auth, string voiceCloningKey = null)
{
    _auth = auth ?? throw new ArgumentNullException(nameof(auth));
    _apiKey = null;
    _voiceCloningKey = voiceCloningKey;
}
```
Keep the existing `ChirpTTSClient(string apiKey, string voiceCloningKey = null)` constructor unchanged. It sets `_auth = null`.

**4. Modify SynthesizeAsync** -- change the endpoint and auth header logic:
- Select endpoint: `string endpoint = _auth != null ? TTS_ENDPOINT_V1BETA1 : TTS_ENDPOINT_V1;`
- Replace `using var request = new UnityWebRequest(TTS_ENDPOINT, "POST")` with `using var request = new UnityWebRequest(endpoint, "POST")`
- Replace the `request.SetRequestHeader("x-goog-api-key", _apiKey)` line with:
```csharp
if (_auth != null)
{
    string token = await _auth.GetAccessTokenAsync();
    request.SetRequestHeader("Authorization", "Bearer " + token);
    request.SetRequestHeader("x-goog-user-project", _auth.ProjectId);
}
else
{
    request.SetRequestHeader("x-goog-api-key", _apiKey);
}
```
IMPORTANT: The `await _auth.GetAccessTokenAsync()` call MUST happen BEFORE `await request.SendWebRequest()`. This is an additional await point -- ensure it sits between creating the request and sending it.

**5. Update Dispose** -- add `_auth?.Dispose()` in the Dispose method (ChirpTTSClient takes ownership of the auth when constructed with the auth overload).

**6. Update the XML doc** on the class to mention bearer auth support. Update the constructor docs. Add `<see cref="GoogleServiceAccountAuth"/>` references where appropriate.

**7. Update the error message** in the catch block -- replace the "ensure Cloud Text-to-Speech API is enabled" message with a more helpful one that accounts for both auth paths:
```csharp
$"Cloud TTS request failed ({endpoint}): {request.error}\n" +
$"Response: {request.downloadHandler?.text ?? "(no body)"}\n" +
(_auth != null
    ? "Check: service account has Cloud TTS API access, project billing is enabled."
    : "Check: API key has Cloud TTS API enabled in Google Cloud Console.");
```

Do NOT change: BuildRequestJson, ExtractAudioContent, ConvertLinear16ToFloat, WAV_HEADER_SIZE, SAMPLE_RATE. The request body structure is identical for both auth paths.
  </action>
  <verify>
Read ChirpTTSClient.cs. Contains: `TTS_ENDPOINT_V1BETA1`, `GoogleServiceAccountAuth _auth`, constructor overload accepting `GoogleServiceAccountAuth`, `GetAccessTokenAsync` call in SynthesizeAsync, `Authorization`, `Bearer`, `x-goog-user-project`, `_auth?.Dispose()`. Does NOT change BuildRequestJson or ConvertLinear16ToFloat.
  </verify>
  <done>
ChirpTTSClient supports both API key auth (v1 endpoint) and bearer token auth (v1beta1 endpoint). When constructed with GoogleServiceAccountAuth, it uses bearer tokens with auto-refresh and includes x-goog-user-project header. When constructed with API key string, it behaves exactly as before.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire service account auth into PersonaSession TTS provider creation</name>
  <files>Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs</files>
  <action>
Modify PersonaSession to create GoogleServiceAccountAuth from AIEmbodimentSettings when service account is configured, and pass it to ChirpTTSClient.

**1. Add auth field** -- add `private GoogleServiceAccountAuth _serviceAuth;` alongside the existing `_ttsProvider` field near line 98.

**2. Modify Connect() TTS provider initialization** -- replace the ChirpTTS instantiation block (around lines 204-209) with:

```csharp
if (_config.voiceBackend == VoiceBackend.ChirpTTS)
{
    string serviceAccountJson = settings.LoadServiceAccountJson();
    string voiceCloningKey = _config.IsCustomChirpVoice ? _config.voiceCloningKey : null;

    if (serviceAccountJson != null)
    {
        // Bearer auth path: service account enables v1beta1 endpoint (required for custom voice cloning)
        _serviceAuth = new GoogleServiceAccountAuth(serviceAccountJson);
        _ttsProvider = new ChirpTTSClient(_serviceAuth, voiceCloningKey);
    }
    else
    {
        // API key fallback: v1 endpoint (standard voices only, no custom voice cloning)
        _ttsProvider = new ChirpTTSClient(settings.ApiKey, voiceCloningKey);

        if (!string.IsNullOrEmpty(voiceCloningKey))
        {
            Debug.LogWarning(
                "PersonaSession: Voice cloning key set but no service account configured. " +
                "Custom voice cloning requires bearer auth via service account. " +
                "Configure a service account in AIEmbodimentSettings.");
        }
    }
}
```

Note: When bearer auth is used, the API key validation at the top of Connect() should NOT block connection if the API key is empty but a service account exists. Modify the API key guard (around line 148) to also allow connection when service account is configured:

```csharp
var settings = AIEmbodimentSettings.Instance;
if (settings == null)
{
    Debug.LogError(
        "PersonaSession: No AIEmbodimentSettings found. " +
        "Create an AIEmbodimentSettings asset: Assets > Create > AI Embodiment > Settings, " +
        "place it in a Resources folder.");
    return;
}

// API key is required for Gemini Live connection (always)
if (string.IsNullOrEmpty(settings.ApiKey))
{
    Debug.LogError(
        "PersonaSession: No API key configured. " +
        "Set the API key in AIEmbodimentSettings. " +
        "API key is required for Gemini Live connection.");
    return;
}
```

The API key check stays as-is because the Gemini Live WebSocket connection ALWAYS needs an API key (the bearer auth is only for TTS requests, not the Gemini session itself).

**3. Modify Disconnect()** -- add `_serviceAuth` cleanup BEFORE the `_ttsProvider` disposal (around line 822):

```csharp
// Dispose service account auth (must happen after TTS provider disposal since
// ChirpTTSClient.Dispose also disposes auth -- but defensive null check is fine)
if (_serviceAuth != null)
{
    _serviceAuth.Dispose();
    _serviceAuth = null;
}
```

Actually, since ChirpTTSClient.Dispose() now disposes its `_auth`, and PersonaSession holds the same reference in `_serviceAuth`, we should NOT double-dispose. Instead: remove `_auth?.Dispose()` from the ChirpTTSClient (Task 1 adjustment) -- OR -- simply null out `_serviceAuth` without calling Dispose (let ChirpTTSClient own the lifetime).

The cleaner pattern: PersonaSession owns the lifetime. In ChirpTTSClient, do NOT dispose _auth in Dispose() (it doesn't own it). In PersonaSession, dispose _serviceAuth after disposing _ttsProvider. This is consistent with the existing pattern where PersonaSession owns _ttsProvider lifecycle.

So: Update the approach -- in Task 1, do NOT add `_auth?.Dispose()` to ChirpTTSClient.Dispose(). Instead, in PersonaSession:

After the existing `_ttsProvider` disposal block:
```csharp
if (_serviceAuth != null)
{
    _serviceAuth.Dispose();
    _serviceAuth = null;
}
```

**4. Modify OnDestroy()** -- add the same `_serviceAuth` cleanup after the `_ttsProvider` disposal block (around line 866):

```csharp
if (_serviceAuth != null)
{
    _serviceAuth.Dispose();
    _serviceAuth = null;
}
```
  </action>
  <verify>
Read PersonaSession.cs. Contains: `GoogleServiceAccountAuth _serviceAuth`, `new GoogleServiceAccountAuth(serviceAccountJson)`, `new ChirpTTSClient(_serviceAuth, voiceCloningKey)`, `LoadServiceAccountJson()` call, `_serviceAuth.Dispose()` in both Disconnect() and OnDestroy(), warning log when voiceCloningKey is set without service account.
  </verify>
  <done>
PersonaSession creates GoogleServiceAccountAuth from settings when service account is configured, passes it to ChirpTTSClient for bearer auth, falls back to API key auth when no service account exists, warns when custom voice cloning is attempted without bearer auth, and properly disposes the auth on disconnect/destroy.
  </done>
</task>

</tasks>

<verification>
1. ChirpTTSClient has dual-path auth: bearer token (v1beta1) when GoogleServiceAccountAuth provided, API key (v1) when not
2. ChirpTTSClient calls `_auth.GetAccessTokenAsync()` before each request (token caching/refresh handled by auth class)
3. ChirpTTSClient sends `Authorization: Bearer` and `x-goog-user-project` headers when using bearer auth
4. PersonaSession loads service account JSON from AIEmbodimentSettings and creates GoogleServiceAccountAuth
5. PersonaSession falls back to API key when no service account is configured
6. PersonaSession warns when voice cloning key is set without service account
7. PersonaSession disposes GoogleServiceAccountAuth in both Disconnect() and OnDestroy()
8. API key auth path (existing behavior) is completely unchanged when no service account is configured
</verification>

<success_criteria>
- Custom voice synthesis requests target `texttospeech.googleapis.com/v1beta1/text:synthesize` with bearer auth and voiceClone body
- Standard Chirp voices work via same bearer auth path when service account configured
- Standard Chirp voices continue working via API key when no service account configured (backward compatible)
- No credential leaks: service account is loaded from file path, never serialized into assets shipped in builds
- Auth lifecycle is properly managed: created in Connect, disposed in Disconnect/OnDestroy
</success_criteria>

<output>
After completion, create `.planning/phases/11.2-chirp-custom-voice-bearer-auth/11.2-02-SUMMARY.md`
</output>
