---
phase: 11.2-chirp-custom-voice-bearer-auth
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/GoogleServiceAccountAuth.cs
  - Packages/com.google.ai-embodiment/Runtime/GoogleServiceAccountAuth.cs.meta
  - Packages/com.google.ai-embodiment/Runtime/AIEmbodimentSettings.cs
  - Packages/com.google.ai-embodiment/Editor/AIEmbodimentSettingsEditor.cs
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "GoogleServiceAccountAuth loads a service account JSON, signs a JWT with RSA SHA-256, exchanges it for an OAuth2 access token, and caches the token with automatic refresh before expiry"
    - "AIEmbodimentSettings provides a LoadServiceAccountJson() method that reads service account JSON from a file path stored in the ScriptableObject"
    - "AIEmbodimentSettingsEditor shows a file picker for the service account JSON path with masked display"
    - "Service account JSON files are excluded from git via .gitignore"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/GoogleServiceAccountAuth.cs"
      provides: "OAuth2 service account credential provider with JWT signing and token caching"
      exports: ["GoogleServiceAccountAuth"]
      min_lines: 80
    - path: "Packages/com.google.ai-embodiment/Runtime/GoogleServiceAccountAuth.cs.meta"
      provides: "Unity meta file for GoogleServiceAccountAuth"
    - path: "Packages/com.google.ai-embodiment/Runtime/AIEmbodimentSettings.cs"
      provides: "Service account JSON path field and LoadServiceAccountJson method"
      contains: "LoadServiceAccountJson"
    - path: "Packages/com.google.ai-embodiment/Editor/AIEmbodimentSettingsEditor.cs"
      provides: "Editor UI for service account file path"
      contains: "_serviceAccountJsonPath"
  key_links:
    - from: "GoogleServiceAccountAuth"
      to: "oauth2.googleapis.com/token"
      via: "UnityWebRequest POST with WWWForm"
      pattern: "oauth2\\.googleapis\\.com/token"
    - from: "GoogleServiceAccountAuth"
      to: "RSA.SignData"
      via: "JWT RS256 signing"
      pattern: "SignData.*SHA256"
    - from: "AIEmbodimentSettings"
      to: "GoogleServiceAccountAuth"
      via: "LoadServiceAccountJson provides JSON string for auth constructor"
      pattern: "LoadServiceAccountJson"
---

<objective>
Create the OAuth2 service account authentication infrastructure and settings UI for bearer token auth.

Purpose: Provides the credential foundation that ChirpTTSClient needs to authenticate with Google Cloud TTS v1beta1 for custom voice cloning. Separates auth concern from TTS concern via a standalone credential provider class.

Output: GoogleServiceAccountAuth.cs (JWT signing + token exchange + caching), updated AIEmbodimentSettings with service account path, updated editor UI with file picker, .meta file, .gitignore updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11.2-chirp-custom-voice-bearer-auth/11.2-RESEARCH.md

@Packages/com.google.ai-embodiment/Runtime/AIEmbodimentSettings.cs
@Packages/com.google.ai-embodiment/Editor/AIEmbodimentSettingsEditor.cs
@Packages/com.google.ai-embodiment/Runtime/ChirpTTSClient.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GoogleServiceAccountAuth credential provider</name>
  <files>
    Packages/com.google.ai-embodiment/Runtime/GoogleServiceAccountAuth.cs
    Packages/com.google.ai-embodiment/Runtime/GoogleServiceAccountAuth.cs.meta
  </files>
  <action>
Create `GoogleServiceAccountAuth.cs` in the Runtime folder. This is a plain C# class (not MonoBehaviour) that implements `IDisposable`. Namespace: `AIEmbodiment`.

**Constructor** `GoogleServiceAccountAuth(string serviceAccountJson)`:
- Parse the JSON with `JObject.Parse` (Newtonsoft.Json, already a project dependency)
- Extract `client_email`, `project_id`, and `private_key` fields
- Strip PEM headers from `private_key` (`-----BEGIN PRIVATE KEY-----`, `-----END PRIVATE KEY-----`, newlines), decode base64, import via `RSA.Create()` + `ImportPkcs8PrivateKey(keyBytes, out _)`
- Store `_clientEmail`, `_projectId`, `_rsa` as readonly fields
- Throw `ArgumentException` if JSON is missing required fields

**Public property** `string ProjectId => _projectId` (needed by ChirpTTSClient for `x-goog-user-project` header)

**Public method** `async Awaitable<string> GetAccessTokenAsync()`:
- If `_cachedToken != null` and `DateTime.UtcNow.AddSeconds(TOKEN_REFRESH_MARGIN_SECONDS) < _tokenExpiry`, return `_cachedToken` immediately
- Otherwise: call `BuildSignedJwt()` to create JWT, call `ExchangeJwtForToken(jwt)` to exchange it, cache the result
- `TOKEN_REFRESH_MARGIN_SECONDS = 300` (5 minutes before 1-hour expiry)

**Private method** `string BuildSignedJwt()`:
- Header: `{"alg":"RS256","typ":"JWT"}` Base64url-encoded
- Claims: `{"iss": _clientEmail, "scope": "https://www.googleapis.com/auth/cloud-platform", "aud": "https://oauth2.googleapis.com/token", "iat": unixNow, "exp": unixNow + 3600}` Base64url-encoded using `JsonConvert.SerializeObject`
- Signature: `_rsa.SignData(Encoding.UTF8.GetBytes(header + "." + claims), HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1)` Base64url-encoded
- Return `header.claims.signature`

**Private static method** `string Base64UrlEncode(byte[] data)`:
- `Convert.ToBase64String(data).TrimEnd('=').Replace('+', '-').Replace('/', '_')`
- CRITICAL: Must use Base64url, not standard Base64 (Research Pitfall 2)

**Private async method** `Awaitable<string> ExchangeJwtForToken(string jwt)`:
- Create `WWWForm` with fields: `grant_type` = `urn:ietf:params:oauth:grant-type:jwt-bearer`, `assertion` = jwt
- CRITICAL: Must use form-encoded POST, NOT JSON body (Research Pitfall 4)
- POST to `https://oauth2.googleapis.com/token` using `UnityWebRequest.Post(url, form)`
- Parse response JSON with `JObject.Parse`, extract `access_token` and `expires_in`
- Set `_tokenExpiry = DateTime.UtcNow.AddSeconds(expiresIn)`
- Throw descriptive Exception on failure including `request.error` and response body

**Dispose**: dispose the RSA instance, null out cached token

**Required usings**: System, System.Security.Cryptography, System.Text, Newtonsoft.Json, UnityEngine, UnityEngine.Networking

**Meta file**: Create a 2-line .meta file with a unique GUID (use `System.Guid.NewGuid().ToString("N")` pattern). Follow the existing package convention (2-line format, no MonoImporter block -- see decision 11-01).
  </action>
  <verify>
File exists at `Packages/com.google.ai-embodiment/Runtime/GoogleServiceAccountAuth.cs`. File contains: `class GoogleServiceAccountAuth`, `GetAccessTokenAsync`, `BuildSignedJwt`, `Base64UrlEncode`, `ExchangeJwtForToken`, `ImportPkcs8PrivateKey`, `oauth2.googleapis.com/token`, `cloud-platform` scope. Meta file exists alongside it.
  </verify>
  <done>
GoogleServiceAccountAuth class exists with JWT signing (RS256), token exchange (form-encoded POST), token caching with 5-minute refresh margin, ProjectId property, and IDisposable cleanup. Meta file exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add service account path to AIEmbodimentSettings and update editor UI</name>
  <files>
    Packages/com.google.ai-embodiment/Runtime/AIEmbodimentSettings.cs
    Packages/com.google.ai-embodiment/Editor/AIEmbodimentSettingsEditor.cs
  </files>
  <action>
**AIEmbodimentSettings.cs** -- Add a service account JSON file path field:

1. Add `[SerializeField] private string _serviceAccountJsonPath = "";` after the existing `_apiKey` field
2. Add public property `public string ServiceAccountJsonPath => _serviceAccountJsonPath;` for read access
3. Add method `public string LoadServiceAccountJson()`:
   - If `_serviceAccountJsonPath` is null or empty, return null
   - If `!System.IO.File.Exists(_serviceAccountJsonPath)`, log `Debug.LogError($"Service account JSON not found: {_serviceAccountJsonPath}")` and return null
   - Return `System.IO.File.ReadAllText(_serviceAccountJsonPath)`
   - Add `using System.IO;` at top (or use fully qualified)

**AIEmbodimentSettingsEditor.cs** -- Add service account UI:

1. Add `SerializedProperty _serviceAccountJsonPath;` field
2. Add `private bool _showServiceAccountPath;` toggle
3. In `OnEnable()`, add `_serviceAccountJsonPath = serializedObject.FindProperty("_serviceAccountJsonPath");`
4. In `OnInspectorGUI()`, after the API Key section, add a new section:

```
EditorGUILayout.Space();
EditorGUILayout.LabelField("Service Account (Optional)", EditorStyles.boldLabel);
```

Add a horizontal layout with:
- A text field showing the path (or masked as dots if `_showServiceAccountPath` is false)
- A "Show"/"Hide" toggle button (same pattern as API key)
- A "Browse..." button that opens `EditorUtility.OpenFilePanel("Select Service Account JSON", "", "json")` and sets the path

Add a HelpBox below:
- If path is empty: "Optional. Required for Chirp custom voice cloning (bearer auth). Get a service account JSON key from Google Cloud Console > IAM & Admin > Service Accounts."
- If path is set but file does not exist: "File not found at the specified path." (MessageType.Error)
- If path is set and file exists: "Service account configured. Bearer auth will be used for Chirp TTS." (MessageType.Info)

For the file-exists check, use `System.IO.File.Exists(_serviceAccountJsonPath.stringValue)`.
  </action>
  <verify>
Read both files. AIEmbodimentSettings.cs contains `_serviceAccountJsonPath`, `LoadServiceAccountJson`, and returns null for empty path. AIEmbodimentSettingsEditor.cs contains `_serviceAccountJsonPath`, `OpenFilePanel`, "Browse", and conditional HelpBox messages.
  </verify>
  <done>
AIEmbodimentSettings has a serialized service account path field with LoadServiceAccountJson() method. AIEmbodimentSettingsEditor shows a masked path field with Show/Hide toggle, Browse button for file picker, and contextual help messages.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update .gitignore for service account JSON files</name>
  <files>.gitignore</files>
  <action>
Add service account JSON patterns to the existing `.gitignore` file, under the "API keys / secrets" section:

```
# Service account credentials (sensitive -- never commit)
*.service-account.json
*-service-account.json
service-account*.json
```

These patterns cover common naming conventions for service account files without being so broad as to catch unrelated JSON files.
  </action>
  <verify>
Read `.gitignore`. Contains service account JSON exclusion patterns.
  </verify>
  <done>
Service account JSON files are excluded from version control via .gitignore patterns.
  </done>
</task>

</tasks>

<verification>
1. `GoogleServiceAccountAuth.cs` exists with complete JWT signing flow (RS256), token exchange (form-encoded POST to oauth2.googleapis.com/token), token caching with 5-min refresh margin, ProjectId property, IDisposable
2. `GoogleServiceAccountAuth.cs.meta` exists alongside the source file
3. `AIEmbodimentSettings.cs` has `_serviceAccountJsonPath` field and `LoadServiceAccountJson()` method
4. `AIEmbodimentSettingsEditor.cs` has file picker UI with Browse button, Show/Hide toggle, and contextual HelpBox
5. `.gitignore` has service account JSON exclusion patterns
</verification>

<success_criteria>
- GoogleServiceAccountAuth is a standalone class ready to be consumed by ChirpTTSClient (Plan 02)
- AIEmbodimentSettings can load service account JSON from a configured file path
- Editor UI provides a clear way to configure the service account path with visual feedback
- Service account files are protected from accidental git commits
</success_criteria>

<output>
After completion, create `.planning/phases/11.2-chirp-custom-voice-bearer-auth/11.2-01-SUMMARY.md`
</output>
