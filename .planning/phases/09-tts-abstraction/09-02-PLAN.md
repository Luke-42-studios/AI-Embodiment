---
phase: 09-tts-abstraction
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
  - Packages/com.google.ai-embodiment/Editor/PersonaConfigEditor.cs
autonomous: true

must_haves:
  truths:
    - "When voice backend is ChirpTTS, Gemini native audio is discarded and outputTranscription text is routed through ITTSProvider"
    - "When voice backend is Custom, a developer-supplied ITTSProvider MonoBehaviour receives synthesis requests"
    - "When voice backend is GeminiNative, no TTS provider is active and native audio plays directly"
    - "Inspector shows Custom backend UI with MonoBehaviour slot and interface validation"
    - "Inspector shows synthesisMode for both ChirpTTS and Custom backends"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs"
      provides: "Provider-agnostic TTS routing via ITTSProvider"
      contains: "_ttsProvider"
    - path: "Packages/com.google.ai-embodiment/Editor/PersonaConfigEditor.cs"
      provides: "Custom backend Inspector UI with validation"
      contains: "VoiceBackend.Custom"
  key_links:
    - from: "Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs"
      to: "ITTSProvider.SynthesizeAsync"
      via: "_ttsProvider field"
      pattern: "_ttsProvider\\.SynthesizeAsync"
    - from: "Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs"
      to: "PersonaConfig.CustomTTSProvider"
      via: "Connect() provider resolution"
      pattern: "_config\\.CustomTTSProvider"
    - from: "Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs"
      to: "AudioPlayback.EnqueueAudio"
      via: "SynthesizeAndEnqueue after TTSResult"
      pattern: "_audioPlayback\\.EnqueueAudio\\(result\\.Samples\\)"
---

<objective>
Rewrite PersonaSession to use ITTSProvider instead of ChirpTTSClient directly, generalizing all TTS routing to work with any provider. Update PersonaConfigEditor for Custom backend UI with interface validation and provider-agnostic synthesis mode display.

Purpose: Complete the TTS abstraction so PersonaSession routes text through any ITTSProvider (ChirpTTS or Custom), with the Inspector fully supporting all three voice backends.
Output: PersonaSession with provider-agnostic TTS routing, PersonaConfigEditor with Custom backend support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-tts-abstraction/09-CONTEXT.md
@.planning/phases/09-tts-abstraction/09-RESEARCH.md
@.planning/phases/09-tts-abstraction/09-01-SUMMARY.md

# Source files to modify
@Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
@Packages/com.google.ai-embodiment/Editor/PersonaConfigEditor.cs

# Reference files (read-only, for understanding interfaces)
@Packages/com.google.ai-embodiment/Runtime/ITTSProvider.cs
@Packages/com.google.ai-embodiment/Runtime/ChirpTTSClient.cs
@Packages/com.google.ai-embodiment/Runtime/PersonaConfig.cs
@Packages/com.google.ai-embodiment/Runtime/VoiceBackend.cs
@Packages/com.google.ai-embodiment/Runtime/AudioPlayback.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generalize PersonaSession TTS routing from ChirpTTSClient to ITTSProvider</name>
  <files>Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs</files>
  <action>
Replace all Chirp-specific TTS code in PersonaSession with provider-agnostic ITTSProvider code. This is the core routing generalization.

**Field changes:**
1. Replace `private ChirpTTSClient _chirpClient;` with `private ITTSProvider _ttsProvider;`
2. Rename `_chirpTextBuffer` to `_ttsTextBuffer` (the StringBuilder instance)
3. Rename `_chirpSynthesizing` to `_ttsSynthesizing` (if still used; check whether it's referenced -- based on current code it exists but is never checked, so remove it as dead code)

**Connect() changes:**
Replace the Chirp TTS initialization block:
```csharp
// Old:
if (_config.voiceBackend == VoiceBackend.ChirpTTS)
{
    _chirpClient = new ChirpTTSClient(settings.ApiKey);
    _chirpClient.OnError += HandleChirpError;
}
```
With provider-agnostic resolution:
```csharp
if (_config.voiceBackend == VoiceBackend.ChirpTTS)
{
    _ttsProvider = new ChirpTTSClient(
        settings.ApiKey,
        _config.IsCustomChirpVoice ? _config.voiceCloningKey : null);
}
else if (_config.voiceBackend == VoiceBackend.Custom)
{
    _ttsProvider = _config.CustomTTSProvider;
    if (_ttsProvider == null)
    {
        Debug.LogError("PersonaSession: VoiceBackend.Custom selected but no ITTSProvider assigned in PersonaConfig.");
    }
}
// GeminiNative: _ttsProvider remains null
```
Note: No `OnError +=` subscription -- ChirpTTSClient no longer has OnError event (removed in Plan 01). Errors are caught in SynthesizeAndEnqueue's try/catch.

**HandleAudioEvent() changes:**
Replace `_config.voiceBackend == VoiceBackend.GeminiNative` check with `_ttsProvider == null` (semantically equivalent but decoupled from enum):
```csharp
if (_ttsProvider == null)
{
    // Native audio path (GeminiNative or Custom with no provider assigned)
    _audioPlayback?.EnqueueAudio(ev.AudioData);
    // ... rest of native audio handling unchanged
}
// If _ttsProvider != null: discard Gemini audio (TTS provider handles playback)
```
Update the comment from "If voiceBackend is ChirpTTS" to "If _ttsProvider != null: discard Gemini audio (TTS provider handles playback)".

**HandleOutputTranscription() changes:**
Replace `_config.voiceBackend == VoiceBackend.ChirpTTS` with `_ttsProvider != null`:
```csharp
if (_ttsProvider != null)
{
    _ttsTextBuffer.Append(text);
}
```

**HandleTurnCompleteEvent() changes:**
Replace Chirp-specific full-response synthesis:
```csharp
// Old:
if (_config.voiceBackend == VoiceBackend.ChirpTTS
    && _config.chirpSynthesisMode == ChirpSynthesisMode.FullResponse
    && _chirpTextBuffer.Length > 0)
```
With:
```csharp
if (_ttsProvider != null
    && _config.synthesisMode == TTSSynthesisMode.FullResponse
    && _ttsTextBuffer.Length > 0)
{
    string fullText = _ttsTextBuffer.ToString();
    _ttsTextBuffer.Clear();
    SynthesizeAndEnqueue(fullText);
}
```

**HandleInterruptedEvent() changes:**
Replace `_chirpTextBuffer.Clear()` with `_ttsTextBuffer.Clear()`.

**HandleSyncPacket() changes:**
Replace Chirp-specific sentence-by-sentence synthesis:
```csharp
// Old:
if (_config.voiceBackend == VoiceBackend.ChirpTTS
    && _config.chirpSynthesisMode == ChirpSynthesisMode.SentenceBySentence
    && packet.Type == SyncPacketType.TextAudio
    && !string.IsNullOrEmpty(packet.Text))
```
With:
```csharp
if (_ttsProvider != null
    && _config.synthesisMode == TTSSynthesisMode.SentenceBySentence
    && packet.Type == SyncPacketType.TextAudio
    && !string.IsNullOrEmpty(packet.Text))
```

**SynthesizeAndEnqueue() changes -- full rewrite:**
```csharp
private async void SynthesizeAndEnqueue(string text)
{
    if (_ttsProvider == null || _audioPlayback == null || string.IsNullOrEmpty(text)) return;

    try
    {
        string voiceName = _config.voiceBackend == VoiceBackend.ChirpTTS
            ? (_config.IsCustomChirpVoice ? _config.customVoiceName : _config.chirpVoiceShortName)
            : _config.customVoiceName;
        string languageCode = _config.chirpLanguageCode;

        if (!_aiSpeaking)
        {
            _aiSpeaking = true;
            OnAISpeakingStarted?.Invoke();
        }

        TTSResult result = await _ttsProvider.SynthesizeAsync(text, voiceName, languageCode);

        if (result.HasAudio && _audioPlayback != null)
        {
            if (result.SampleRate != 24000)
            {
                Debug.LogWarning(
                    $"PersonaSession: TTS provider returned {result.SampleRate}Hz audio. " +
                    "AudioPlayback expects 24000Hz. Audio may play at wrong speed.");
            }
            _audioPlayback.EnqueueAudio(result.Samples);
        }
    }
    catch (Exception ex)
    {
        OnError?.Invoke(ex);
        Debug.LogWarning($"PersonaSession: TTS synthesis failed (text still displayed): {ex.Message}");
    }
}
```
Key differences from current code:
- Uses `_ttsProvider` instead of `_chirpClient`
- No voiceCloningKey parameter (moved to ChirpTTSClient constructor)
- Gets TTSResult back, checks SampleRate, uses result.Samples
- Uses `chirpVoiceShortName` for standard Chirp voices (matches existing `_config.chirpVoiceShortName` pattern -- note: the current code uses `chirpVoiceShortName` not `chirpVoiceName` for the API call, which is a short name; the full API name is constructed by Cloud TTS from languageCode + voice internally)
- Error catching routes to OnError (same as before, but without the redundant HandleChirpError path)

**Remove HandleChirpError method entirely.** It is dead code after the OnError event removal from ChirpTTSClient. The MainThreadDispatcher.Enqueue wrapper was necessary when errors came from a background thread -- but ChirpTTSClient.SynthesizeAsync runs on the main thread (UnityWebRequest requirement), so the try/catch in SynthesizeAndEnqueue already handles errors on the main thread.

**Disconnect() changes:**
Replace the _chirpClient cleanup block:
```csharp
// Old:
if (_chirpClient != null)
{
    _chirpClient.OnError -= HandleChirpError;
    _chirpClient.Dispose();
    _chirpClient = null;
}
_chirpTextBuffer.Clear();
```
With:
```csharp
if (_ttsProvider != null)
{
    _ttsProvider.Dispose();
    _ttsProvider = null;
}
_ttsTextBuffer.Clear();
```

**OnDestroy() changes:**
Replace the _chirpClient cleanup block (same pattern as Disconnect):
```csharp
// Old:
if (_chirpClient != null)
{
    _chirpClient.OnError -= HandleChirpError;
    _chirpClient.Dispose();
    _chirpClient = null;
}
```
With:
```csharp
if (_ttsProvider != null)
{
    _ttsProvider.Dispose();
    _ttsProvider = null;
}
```

**Add SetTTSProvider public method** (per CONTEXT.md -- code API for provider registration):
```csharp
/// <summary>
/// Sets a custom TTS provider for the next session. Must be called before Connect().
/// Throws if called while a session is active.
/// </summary>
/// <param name="provider">The ITTSProvider implementation to use, or null to use config defaults.</param>
public void SetTTSProvider(ITTSProvider provider)
{
    if (State != SessionState.Disconnected)
    {
        Debug.LogError("PersonaSession: SetTTSProvider must be called before Connect(). Current state: " + State);
        return;
    }
    _ttsProvider = provider;
}
```
Place after the existing RegisterFunction method (public API section).

**Final sweep:** Grep for any remaining `_chirpClient`, `_chirpTextBuffer`, `_chirpSynthesizing`, `HandleChirpError`, `ChirpSynthesisMode` references in PersonaSession.cs and replace/remove them.
  </action>
  <verify>
Grep for `_chirpClient` in PersonaSession.cs -- must return zero matches.
Grep for `_chirpTextBuffer` in PersonaSession.cs -- must return zero matches.
Grep for `HandleChirpError` in PersonaSession.cs -- must return zero matches.
Grep for `ChirpSynthesisMode` in PersonaSession.cs -- must return zero matches.
Grep for `_ttsProvider` in PersonaSession.cs -- must return multiple matches (field, Connect, Disconnect, OnDestroy, SynthesizeAndEnqueue, HandleAudioEvent, HandleOutputTranscription, HandleTurnCompleteEvent, HandleSyncPacket).
Grep for `_ttsTextBuffer` in PersonaSession.cs -- must return matches.
Grep for `SetTTSProvider` in PersonaSession.cs -- must return the public method.
Grep for `TTSSynthesisMode` in PersonaSession.cs -- must return matches (HandleTurnCompleteEvent, HandleSyncPacket).
Grep for `MainThreadDispatcher` in PersonaSession.cs -- must return zero matches (HandleChirpError was the last user).
  </verify>
  <done>
PersonaSession uses ITTSProvider throughout. All Chirp-specific field names, methods, and type references replaced with provider-agnostic equivalents. HandleChirpError removed. SetTTSProvider public API added. Zero MainThreadDispatcher references remain.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update PersonaConfigEditor for Custom backend UI and TTSSynthesisMode</name>
  <files>Packages/com.google.ai-embodiment/Editor/PersonaConfigEditor.cs</files>
  <action>
Update the PersonaConfigEditor to support all three VoiceBackend values and the renamed synthesis mode.

**Property additions in fields section:**
```csharp
SerializedProperty _synthesisMode;      // replaces _chirpSynthesisMode
SerializedProperty _customTTSProvider;  // new: Custom backend MonoBehaviour slot
```

**OnEnable() changes:**
- Replace `_chirpSynthesisMode = serializedObject.FindProperty("chirpSynthesisMode");` with `_synthesisMode = serializedObject.FindProperty("synthesisMode");`
- Add `_customTTSProvider = serializedObject.FindProperty("_customTTSProvider");`
- Remove the old `_chirpSynthesisMode` field declaration

**OnInspectorGUI() voice section changes:**
The backend switch needs a third case for Custom:
```csharp
if (backend == VoiceBackend.GeminiNative)
{
    EditorGUILayout.PropertyField(_geminiVoiceName,
        new GUIContent("Voice Name", "Gemini Live API voice name (e.g. Puck, Charon)"));
}
else if (backend == VoiceBackend.ChirpTTS)
{
    DrawChirpFields();
}
else if (backend == VoiceBackend.Custom)
{
    DrawCustomFields();
}
```

**DrawChirpFields() changes:**
- Replace `_chirpSynthesisMode` with `_synthesisMode` everywhere in this method
- Replace `ChirpSynthesisMode` cast with `TTSSynthesisMode`:
  ```csharp
  var mode = (TTSSynthesisMode)_synthesisMode.enumValueIndex;
  if (mode == TTSSynthesisMode.SentenceBySentence)
  ```
- Update the PropertyField label from "Synthesis Mode" to keep same label (label is fine as-is)

**Add new DrawCustomFields() method:**
```csharp
void DrawCustomFields()
{
    // Custom TTS provider MonoBehaviour slot
    EditorGUILayout.PropertyField(_customTTSProvider,
        new GUIContent("TTS Provider", "MonoBehaviour implementing ITTSProvider"));

    // Validate assigned reference at edit time
    var mb = _customTTSProvider.objectReferenceValue as MonoBehaviour;
    if (mb != null && !(mb is ITTSProvider))
    {
        EditorGUILayout.HelpBox(
            $"{mb.GetType().Name} does not implement ITTSProvider.",
            MessageType.Error);
    }
    else if (mb == null && _customTTSProvider.objectReferenceValue != null)
    {
        EditorGUILayout.HelpBox(
            "Assigned object is not a MonoBehaviour.",
            MessageType.Error);
    }

    EditorGUILayout.Space(4);

    // Synthesis mode (shared with ChirpTTS)
    EditorGUILayout.PropertyField(_synthesisMode,
        new GUIContent("Synthesis Mode", "How text is sent to the TTS provider for audio generation"));

    var mode = (TTSSynthesisMode)_synthesisMode.enumValueIndex;
    if (mode == TTSSynthesisMode.SentenceBySentence)
    {
        EditorGUILayout.HelpBox(
            "Each sentence synthesized as it arrives via PacketAssembler.",
            MessageType.Info);
    }
    else if (mode == TTSSynthesisMode.FullResponse)
    {
        EditorGUILayout.HelpBox(
            "Entire response synthesized at once after turn completes.",
            MessageType.Info);
    }
}
```

**Remove old field declarations:**
Remove `SerializedProperty _chirpSynthesisMode;` from the class fields.

The `DrawCustomFields` method must NOT have namespace issues -- the editor assembly references the runtime assembly, so ITTSProvider, TTSSynthesisMode, and VoiceBackend.Custom are all accessible.
  </action>
  <verify>
Grep for `_chirpSynthesisMode` in PersonaConfigEditor.cs -- must return zero matches.
Grep for `ChirpSynthesisMode` in PersonaConfigEditor.cs -- must return zero matches.
Grep for `_synthesisMode` in PersonaConfigEditor.cs -- must return multiple matches.
Grep for `_customTTSProvider` in PersonaConfigEditor.cs -- must return matches (field, OnEnable, DrawCustomFields).
Grep for `DrawCustomFields` in PersonaConfigEditor.cs -- must exist.
Grep for `VoiceBackend.Custom` in PersonaConfigEditor.cs -- must exist.
Grep for `ITTSProvider` in PersonaConfigEditor.cs -- must exist (validation check).
Run a full codebase grep: `grep -r "ChirpSynthesisMode" Packages/com.google.ai-embodiment/` -- must return zero matches across ALL files (Runtime + Editor).
Run a full codebase grep: `grep -r "_chirpClient" Packages/com.google.ai-embodiment/` -- must return zero matches.
  </verify>
  <done>
PersonaConfigEditor supports all three VoiceBackend values. Custom backend shows MonoBehaviour slot with ITTSProvider validation. SynthesisMode shown for both ChirpTTS and Custom. Zero ChirpSynthesisMode references remain anywhere in the package.
  </done>
</task>

</tasks>

<verification>
1. `grep -r "ChirpSynthesisMode" Packages/com.google.ai-embodiment/` returns zero matches (complete enum replacement)
2. `grep -r "_chirpClient" Packages/com.google.ai-embodiment/` returns zero matches (complete field replacement)
3. `grep -r "HandleChirpError" Packages/com.google.ai-embodiment/` returns zero matches (dead code removed)
4. `grep -r "MainThreadDispatcher" Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs` returns zero matches
5. `grep -r "_ttsProvider" Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs` returns field + all usage sites
6. `grep -r "ITTSProvider" Packages/com.google.ai-embodiment/` returns: ITTSProvider.cs (definition), ChirpTTSClient.cs (implements), PersonaConfig.cs (property), PersonaSession.cs (field + SetTTSProvider), PersonaConfigEditor.cs (validation)
7. `grep -r "VoiceBackend.Custom" Packages/com.google.ai-embodiment/` returns: PersonaSession.cs (Connect), PersonaConfigEditor.cs (DrawCustomFields)
</verification>

<success_criteria>
- PersonaSession routes TTS through ITTSProvider (not ChirpTTSClient directly)
- All Chirp-specific naming eliminated from PersonaSession (field names, method names, type refs)
- SynthesizeAndEnqueue handles TTSResult with SampleRate warning
- SetTTSProvider public API exists with state guard
- PersonaConfigEditor shows Custom backend UI with MonoBehaviour slot + ITTSProvider validation
- synthesisMode shown for both ChirpTTS and Custom backends, hidden for GeminiNative
- Zero ChirpSynthesisMode references remain in the entire package
- Zero _chirpClient references remain in the entire package
</success_criteria>

<output>
After completion, create `.planning/phases/09-tts-abstraction/09-02-SUMMARY.md`
</output>
