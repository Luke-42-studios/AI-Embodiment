---
phase: 12-foundation-and-data-model
plan: 03
type: execute
wave: 2
depends_on: ["12-02"]
files_modified:
  - Assets/AyaLiveStream/LivestreamUI.cs
  - Assets/AyaLiveStream/UI/LivestreamPanel.uxml
  - Assets/AyaLiveStream/UI/LivestreamPanel.uss
autonomous: false

must_haves:
  truths:
    - "Livestream UI shell renders in Play Mode with a scrollable ListView chat feed, an Aya transcript panel, a push-to-talk indicator area, and stream status indicators"
    - "Chat messages can be programmatically added to the ListView feed and display with correct bot name, color, and timestamp"
    - "LIVE badge, viewer count, and duration timer are visible in the stream status area"
    - "ListView uses DynamicHeight virtualization for performance with many messages"
  artifacts:
    - path: "Assets/AyaLiveStream/UI/LivestreamPanel.uxml"
      provides: "UXML layout for the full livestream UI"
      contains: "ListView"
      min_lines: 20
    - path: "Assets/AyaLiveStream/UI/LivestreamPanel.uss"
      provides: "USS styles for the livestream UI"
      contains: "chat-feed"
      min_lines: 50
    - path: "Assets/AyaLiveStream/LivestreamUI.cs"
      provides: "MonoBehaviour controller for the livestream UI"
      exports: ["LivestreamUI", "AddMessage"]
      min_lines: 80
  key_links:
    - from: "Assets/AyaLiveStream/LivestreamUI.cs"
      to: "Assets/AyaLiveStream/ChatMessage.cs"
      via: "ListView itemsSource is List<ChatMessage>, bindItem reads ChatMessage fields"
      pattern: "List<ChatMessage>"
    - from: "Assets/AyaLiveStream/LivestreamUI.cs"
      to: "Assets/AyaLiveStream/UI/LivestreamPanel.uxml"
      via: "UIDocument references the UXML asset"
      pattern: "Q<ListView>.*chat-feed"
    - from: "Assets/AyaLiveStream/LivestreamUI.cs"
      to: "Assets/AyaLiveStream/ChatBotConfig.cs"
      via: "ChatMessage.BotColor used in bindItem to color bot name label"
      pattern: "msg\\.BotColor"
---

<objective>
Build the livestream UI shell -- UXML layout, USS styles, and LivestreamUI MonoBehaviour controller with ListView-based chat feed.

Purpose: This is the visual foundation. Every subsequent phase renders through this UI: chat bots post messages here (Phase 13), Aya's transcript appears here (Phase 14), stream status shows session state (Phase 16). The ListView with DynamicHeight virtualization handles potentially hundreds of messages without performance degradation.

Output: LivestreamPanel.uxml (layout), LivestreamPanel.uss (styles), LivestreamUI.cs (controller).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-foundation-and-data-model/12-RESEARCH.md
@.planning/phases/12-foundation-and-data-model/12-02-SUMMARY.md

Key reference files:
@Assets/AyaLiveStream/AyaChatUI.cs (existing UI pattern -- ScrollView approach, but we use ListView instead)
@Assets/AyaLiveStream/UI/AyaPanel.uxml (existing UXML structure to reference for style consistency)
@Assets/AyaLiveStream/UI/AyaPanel.uss (existing USS styles to reference for color/spacing consistency)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LivestreamPanel UXML layout and USS styles</name>
  <files>Assets/AyaLiveStream/UI/LivestreamPanel.uxml, Assets/AyaLiveStream/UI/LivestreamPanel.uss</files>
  <action>
**LivestreamPanel.uxml** -- Create in `Assets/AyaLiveStream/UI/`

Layout structure (livestream-style, dark theme matching AyaPanel):

```
root-container (full-screen flex column)
├── top-bar (horizontal row)
│   ├── live-badge (Label: "LIVE")
│   ├── viewer-count (Label: "0 viewers")
│   └── duration-timer (Label: "00:00")
├── main-content (horizontal row, flex-grow)
│   ├── chat-panel (left side, ~60% width)
│   │   ├── chat-feed (ListView -- the core chat message list)
│   │   └── chat-input-area (bottom of chat panel, placeholder for future user input)
│   └── aya-panel (right side, ~40% width)
│       ├── aya-header (horizontal row)
│       │   ├── speaking-indicator (circle)
│       │   └── aya-name (Label: "Aya")
│       ├── aya-transcript (ScrollView -- Aya's current speech text, uses existing pattern)
│       └── ptt-area (push-to-talk indicator area)
│           └── ptt-status (Label: "Hold SPACE to talk")
└── (no footer -- top-bar serves as status)
```

ListView UXML attributes for chat-feed:
```xml
<ui:ListView name="chat-feed"
    virtualization-method="DynamicHeight"
    fixed-item-height="40"
    selection-type="None"
    show-alternating-row-backgrounds="None"
    show-border="false"
    reorderable="false"
    class="chat-feed" />
```

The Aya transcript panel uses ScrollView (same approach as existing AyaChatUI):
```xml
<ui:ScrollView name="aya-transcript" class="aya-transcript"
    vertical-scroller-visibility="Auto"
    horizontal-scroller-visibility="Hidden" />
```

Reference the USS stylesheet:
```xml
<Style src="LivestreamPanel.uss" />
```

**LivestreamPanel.uss** -- Create in `Assets/AyaLiveStream/UI/`

Match the dark theme of AyaPanel.uss (background: rgb(24, 24, 32), text: light colors).

Key styles:

```css
/* Root */
.root { flex-grow: 1; background-color: rgb(24, 24, 32); padding: 8px; }

/* Top bar */
.top-bar { flex-direction: row; align-items: center; justify-content: space-between; margin-bottom: 8px; padding: 4px 8px; }
.live-badge { background-color: rgb(220, 40, 40); color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px; -unity-font-style: bold; }
.viewer-count { color: rgb(180, 180, 200); font-size: 12px; }
.duration-timer { color: rgb(180, 180, 200); font-size: 12px; font-family: monospace; }

/* Main content split */
.main-content { flex-direction: row; flex-grow: 1; }
.chat-panel { flex-grow: 3; margin-right: 8px; }
.aya-panel { flex-grow: 2; min-width: 250px; }

/* Chat feed (ListView) */
.chat-feed { flex-grow: 1; background-color: rgb(16, 16, 24); border-radius: 8px; padding: 4px; }

/* Chat message items (created dynamically by makeItem) */
.chat-message { flex-direction: row; padding: 2px 4px; align-items: flex-start; }
.bot-name { font-size: 13px; -unity-font-style: bold; margin-right: 6px; min-width: 80px; }
.message-text { font-size: 13px; color: rgb(220, 220, 230); white-space: normal; flex-grow: 1; flex-shrink: 1; }
.timestamp { font-size: 10px; color: rgb(100, 100, 120); margin-left: 6px; min-width: 35px; }

/* Chat input area (placeholder for future) */
.chat-input-area { height: 32px; margin-top: 4px; background-color: rgb(32, 32, 44); border-radius: 6px; padding: 4px 8px; justify-content: center; }
.chat-input-placeholder { color: rgb(100, 100, 120); font-size: 12px; }

/* Aya panel */
.aya-header { flex-direction: row; align-items: center; margin-bottom: 8px; }
.aya-indicator { width: 10px; height: 10px; border-radius: 5px; background-color: rgb(80, 80, 80); margin-right: 6px; }
.aya-indicator--speaking { background-color: rgb(100, 255, 100); }
.aya-name { font-size: 18px; color: rgb(220, 180, 255); -unity-font-style: bold; }
.aya-transcript { flex-grow: 1; background-color: rgb(16, 16, 24); border-radius: 8px; padding: 8px; margin-bottom: 8px; }
.aya-msg { color: rgb(200, 170, 255); margin-bottom: 4px; white-space: normal; font-size: 14px; }

/* Push-to-talk area */
.ptt-area { padding: 8px; background-color: rgb(32, 32, 44); border-radius: 6px; align-items: center; }
.ptt-status { color: rgb(140, 140, 160); font-size: 12px; }
.ptt-status--active { color: rgb(255, 120, 120); -unity-font-style: bold; }
```

Do NOT:
- Use ScrollView for the chat feed (use ListView with DynamicHeight)
- Make the layout responsive/mobile-first (desktop-first per constraints)
- Deviate significantly from AyaPanel.uss color scheme
  </action>
  <verify>
1. `Assets/AyaLiveStream/UI/LivestreamPanel.uxml` exists
2. `Assets/AyaLiveStream/UI/LivestreamPanel.uss` exists
3. UXML contains a `ListView` named "chat-feed" with `virtualization-method="DynamicHeight"`
4. UXML contains elements: live-badge, viewer-count, duration-timer, aya-transcript, ptt-status
5. USS has styles for all named elements
6. USS references the stylesheet in UXML via `<Style src="...">`
  </verify>
  <done>
LivestreamPanel.uxml defines the full livestream layout with ListView chat feed, Aya transcript panel, stream status bar (LIVE badge, viewer count, timer), and push-to-talk area. LivestreamPanel.uss provides dark theme styles matching the existing AyaPanel aesthetic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement LivestreamUI MonoBehaviour controller</name>
  <files>Assets/AyaLiveStream/LivestreamUI.cs</files>
  <action>
Create `LivestreamUI.cs` in `Assets/AyaLiveStream/`

Namespace: `AIEmbodiment.Samples`

This is a MonoBehaviour (it binds to UIDocument in the scene).

Serialized fields:
```csharp
[SerializeField] private UIDocument _uiDocument;
```

Private fields:
```csharp
private ListView _chatFeed;
private Label _liveBadge;
private Label _viewerCount;
private Label _durationTimer;
private ScrollView _ayaTranscript;
private VisualElement _ayaIndicator;
private Label _pttStatus;

private readonly List<ChatMessage> _messages = new();
private float _sessionStartTime;
private Label _currentAyaMessage;
```

**OnEnable():**
1. Get root from `_uiDocument.rootVisualElement`
2. Query all named elements using `root.Q<T>("name")`
3. Configure ListView:
   - `_chatFeed.makeItem = MakeChatItem;`
   - `_chatFeed.bindItem = BindChatItem;`
   - `_chatFeed.itemsSource = _messages;`
   - `_chatFeed.virtualizationMethod = CollectionVirtualizationMethod.DynamicHeight;`
   - `_chatFeed.selectionType = SelectionType.None;`
4. Record `_sessionStartTime = Time.time;`

**MakeChatItem() -> VisualElement:**
Create the chat item template matching the UXML/USS classes:
- Container `VisualElement` with class "chat-message"
- Child `Label` named "bot-name" with class "bot-name"
- Child `Label` named "message-text" with class "message-text", set `style.whiteSpace = WhiteSpace.Normal`
- Child `Label` named "timestamp" with class "timestamp"
- Return container

**BindChatItem(VisualElement element, int index):**
1. Get `ChatMessage msg = _messages[index]`
2. Query labels by name from element
3. Set `nameLabel.text = msg.BotName`
4. Set `nameLabel.style.color = msg.BotColor` (Color auto-converts to StyleColor)
5. Set `textLabel.text = msg.Text`
6. Set `timestampLabel.text = msg.Timestamp`

**Public API methods:**

`public void AddMessage(ChatMessage msg)` -- core method for adding chat messages:
1. `_messages.Add(msg)`
2. `_chatFeed.RefreshItems()`
3. Scroll to bottom using deferred execution (from research, matching AyaChatUI AutoScroll pattern):
   ```csharp
   _chatFeed.schedule.Execute(() => _chatFeed.ScrollToItem(_messages.Count - 1));
   ```

`public void UpdateAyaTranscript(string text)` -- streaming Aya speech text:
1. If `_currentAyaMessage == null`, create new Label with class "aya-msg", add to `_ayaTranscript`
2. Update `_currentAyaMessage.text = text`
3. Auto-scroll the aya-transcript ScrollView (use same deferred pattern as AyaChatUI.AutoScroll)

`public void CompleteAyaTurn()` -- Aya finished speaking:
1. Set `_currentAyaMessage = null`

`public void SetAyaSpeaking(bool speaking)` -- toggle speaking indicator:
1. Add/remove "aya-indicator--speaking" class on `_ayaIndicator`

`public void SetPTTStatus(string text, bool active = false)` -- update push-to-talk status:
1. Set `_pttStatus.text = text`
2. Toggle "ptt-status--active" class based on `active`

`public void SetViewerCount(int count)` -- update viewer count display:
1. `_viewerCount.text = $"{count} viewers"`

**Update():**
Update the duration timer:
```csharp
float elapsed = Time.time - _sessionStartTime;
int minutes = (int)(elapsed / 60);
int seconds = (int)(elapsed % 60);
_durationTimer.text = $"{minutes:D2}:{seconds:D2}";
```

Required usings:
```csharp
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;
```

XML doc comments on the class and all public methods.

Do NOT:
- Use ScrollView for the chat feed (ListView with DynamicHeight only)
- Call `Rebuild()` instead of `RefreshItems()` (RefreshItems is lighter weight)
- Call `ScrollToItem()` without deferred `schedule.Execute()` (research pitfall 4)
- Subscribe to PersonaSession events here (that is the controller's job in Phase 14/16)
  </action>
  <verify>
1. `Assets/AyaLiveStream/LivestreamUI.cs` exists and compiles
2. Class is in `AIEmbodiment.Samples` namespace
3. Class is a MonoBehaviour with `[SerializeField] UIDocument _uiDocument`
4. ListView configured with `DynamicHeight`, `makeItem`, `bindItem`, `itemsSource`
5. `AddMessage(ChatMessage)` adds to list, calls RefreshItems, and scrolls to bottom
6. `UpdateAyaTranscript(string)` creates/updates Aya speech labels in ScrollView
7. Duration timer updates in Update()
8. All public methods have XML doc comments
  </verify>
  <done>
LivestreamUI.cs provides the MonoBehaviour controller for the livestream UI. Chat messages can be added programmatically via AddMessage() and display with correct bot name, color, and timestamp in the ListView. Aya transcript, speaking indicator, push-to-talk status, viewer count, and duration timer are all controllable via public methods.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete livestream UI shell: UXML layout with ListView chat feed, Aya transcript panel, stream status indicators (LIVE badge, viewer count, duration timer), and push-to-talk area. Plus the ChatBotConfig/ChatMessage data model from Plan 02.
  </what-built>
  <how-to-verify>
1. Open the Unity project
2. If not already done: run menu item "AI Embodiment > Samples > Migrate Chat Bot Configs" to create the 6 ChatBotConfig assets
3. Verify ChatBotConfig assets appear in Assets/AyaLiveStream/ChatBotConfigs/ (6 assets with distinct names)
4. Select any ChatBotConfig asset and verify all fields are visible and editable in the Inspector (name, color, personality, scripted messages, behavior sliders)
5. Create a new empty scene or use SampleScene
6. Add an empty GameObject, attach a UIDocument component
7. Assign LivestreamPanel.uxml as the Source Asset on the UIDocument
8. Add the LivestreamUI component to the same GameObject
9. Assign the UIDocument reference in the LivestreamUI inspector
10. Enter Play Mode
11. Verify: LIVE badge (red), viewer count, and timer are visible in the top bar
12. Verify: Chat feed area (left) and Aya transcript area (right) are visible
13. Verify: Timer counts up from 00:00
14. Verify: Push-to-talk status area shows "Hold SPACE to talk" at the bottom of the Aya panel
15. (Optional) Add a test script that calls `LivestreamUI.AddMessage()` with test ChatMessages to verify they appear in the ListView with correct name, color, and timestamp
  </how-to-verify>
  <resume-signal>Type "approved" or describe any visual/functional issues to fix</resume-signal>
</task>

</tasks>

<verification>
- LivestreamPanel.uxml contains the full layout with ListView chat-feed, Aya transcript, stream status bar
- LivestreamPanel.uss styles match the dark theme of AyaPanel.uss
- LivestreamUI.cs compiles and provides AddMessage(), UpdateAyaTranscript(), and status methods
- ListView uses DynamicHeight virtualization
- Chat messages display with bot name (colored), message text, and timestamp
- Duration timer updates in real time
- LIVE badge, viewer count visible in top bar
</verification>

<success_criteria>
The livestream UI shell renders in Play Mode with all required areas visible: scrollable ListView chat feed, Aya transcript panel, LIVE badge, viewer count, duration timer, and push-to-talk indicator. Messages can be programmatically added to the chat feed and display with correct formatting.
</success_criteria>

<output>
After completion, create `.planning/phases/12-foundation-and-data-model/12-03-SUMMARY.md`
</output>
