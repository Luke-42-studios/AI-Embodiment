---
phase: 12-foundation-and-data-model
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Assets/AyaLiveStream/GeminiTextClient.cs
autonomous: true

must_haves:
  truths:
    - "GeminiTextClient can send a prompt to gemini-2.5-flash and receive a deserialized structured JSON response matching a provided schema"
    - "GeminiTextClient reuses the existing API key from AIEmbodimentSettings.Instance.ApiKey"
    - "GeminiTextClient follows the ChirpTTSClient pattern: plain C# class, IDisposable, Awaitable return type, UnityWebRequest"
  artifacts:
    - path: "Assets/AyaLiveStream/GeminiTextClient.cs"
      provides: "REST wrapper for Gemini generateContent with structured output"
      exports: ["GeminiTextClient", "GenerateAsync"]
      min_lines: 60
  key_links:
    - from: "Assets/AyaLiveStream/GeminiTextClient.cs"
      to: "Gemini REST API"
      via: "UnityWebRequest POST to v1beta generateContent endpoint"
      pattern: "generativelanguage\\.googleapis\\.com.*generateContent"
    - from: "Assets/AyaLiveStream/GeminiTextClient.cs"
      to: "Packages/com.google.ai-embodiment/Runtime/AIEmbodimentSettings.cs"
      via: "Constructor accepts apiKey string (caller reads from AIEmbodimentSettings.Instance.ApiKey)"
      pattern: "string apiKey"
---

<objective>
Create GeminiTextClient -- a REST wrapper for the Gemini generateContent API with structured JSON output support.

Purpose: Every downstream system (chat bots in Phase 13, dynamic responses in Phase 14) needs a way to call Gemini for structured text generation without going through the WebSocket Live API. This client provides that foundation.

Output: A single `GeminiTextClient.cs` file in `Assets/AyaLiveStream/` that follows the proven ChirpTTSClient pattern exactly.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-foundation-and-data-model/12-RESEARCH.md

Key reference files:
@Packages/com.google.ai-embodiment/Runtime/ChirpTTSClient.cs (THE pattern to follow -- REST + UnityWebRequest + Awaitable + IDisposable)
@Packages/com.google.ai-embodiment/Runtime/AIEmbodimentSettings.cs (API key access pattern)
@Assets/AyaLiveStream/AyaLiveStream.asmdef (assembly definition -- confirms references to com.google.ai-embodiment)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement GeminiTextClient REST wrapper</name>
  <files>Assets/AyaLiveStream/GeminiTextClient.cs</files>
  <action>
Create `GeminiTextClient.cs` in `Assets/AyaLiveStream/` following the ChirpTTSClient pattern exactly.

Namespace: `AIEmbodiment.Samples`

Class design:
- Plain C# class (NOT MonoBehaviour), implements `IDisposable`
- Constructor takes `string apiKey` (caller reads from `AIEmbodimentSettings.Instance.ApiKey`)
- Single public method: `public async Awaitable<T> GenerateAsync<T>(string prompt, JObject responseSchema)`
- Private `_disposed` bool, checked at entry to GenerateAsync and after await

Endpoint: `https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent`
- Store model as a constructor parameter with default `"gemini-2.5-flash"`
- Build endpoint string using the model name

Request body structure (use Newtonsoft.Json JObject):
```json
{
  "contents": [{ "parts": [{ "text": "{prompt}" }] }],
  "generationConfig": {
    "responseMimeType": "application/json",
    "responseSchema": {responseSchema}
  }
}
```

CRITICAL: Use `responseSchema` (not `responseJsonSchema`) with UPPERCASE type constants (STRING, OBJECT, ARRAY, etc.). The research doc confirms this for the v1beta endpoint.

HTTP mechanics (copy ChirpTTSClient exactly):
1. Serialize request body to UTF-8 bytes
2. Create `UnityWebRequest` with POST method
3. Set `UploadHandlerRaw` and `DownloadHandlerBuffer`
4. Set headers: `Content-Type: application/json` and `x-goog-api-key: {_apiKey}`
5. `await request.SendWebRequest()`
6. Check `_disposed` after await, return default if true
7. Check `request.result != Success`, throw with error details and response body

Response parsing (CRITICAL -- Gemini wraps structured JSON inside a text field):
1. `JObject.Parse(request.downloadHandler.text)` to get root response
2. Navigate to `candidates[0].content.parts[0].text` -- this is a JSON STRING, not a parsed object
3. `JsonConvert.DeserializeObject<T>(jsonText)` to get the typed result
4. Return the deserialized result

Error handling:
- Throw `ObjectDisposedException` if disposed before call
- Throw `Exception` with request error + response body on HTTP failure
- Throw `Exception` if `candidates[0].content.parts[0].text` is null (malformed response)

Required usings:
```csharp
using System;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnityEngine;
using UnityEngine.Networking;
```

XML doc comments on class and public method (match ChirpTTSClient documentation quality).

Do NOT:
- Make it a MonoBehaviour (plain C# class with IDisposable)
- Use System.Net.Http.HttpClient (not thread-safe with Unity)
- Use Task<T> return type (use Awaitable<T> for Unity 6)
- Put it in the package directory (goes in Assets/AyaLiveStream/)
- Use `responseJsonSchema` (use `responseSchema`)
- Use lowercase type names in schema (use UPPERCASE: STRING, OBJECT, ARRAY)
  </action>
  <verify>
1. File exists at `Assets/AyaLiveStream/GeminiTextClient.cs`
2. File compiles: open Unity or check for compile errors in the console
3. Class is in `AIEmbodiment.Samples` namespace
4. Class implements `IDisposable`
5. Constructor takes `string apiKey` and optional `string model`
6. `GenerateAsync<T>` returns `Awaitable<T>` and accepts `string prompt, JObject responseSchema`
7. Uses `UnityWebRequest` (not HttpClient)
8. Response parsing navigates `candidates[0].content.parts[0].text` then deserializes
9. Disposed check after await (matching ChirpTTSClient pattern)
  </verify>
  <done>
GeminiTextClient.cs exists in Assets/AyaLiveStream/, compiles without errors, follows ChirpTTSClient pattern (plain C#, IDisposable, Awaitable, UnityWebRequest), and correctly builds Gemini REST requests with responseSchema for structured output. Response parsing extracts the JSON string from candidates[0].content.parts[0].text and deserializes to the generic type T.
  </done>
</task>

</tasks>

<verification>
- `GeminiTextClient.cs` exists and compiles
- Class follows ChirpTTSClient structural pattern (IDisposable, Awaitable, UnityWebRequest)
- Endpoint URL uses v1beta and model name
- Request body includes `responseSchema` with `responseMimeType: application/json`
- Response parsing handles the nested `candidates[0].content.parts[0].text` JSON string
- API key passed via `x-goog-api-key` header
</verification>

<success_criteria>
GeminiTextClient can be instantiated with an API key, called with a prompt and response schema, and will return a deserialized typed object from Gemini's structured output. The implementation is a direct port of the ChirpTTSClient pattern to the Gemini generateContent endpoint.
</success_criteria>

<output>
After completion, create `.planning/phases/12-foundation-and-data-model/12-01-SUMMARY.md`
</output>
