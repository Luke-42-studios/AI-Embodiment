---
phase: 02-audio-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/AudioRingBuffer.cs
  - Packages/com.google.ai-embodiment/Runtime/AudioPlayback.cs
autonomous: true

must_haves:
  truths:
    - "AudioPlayback plays incoming float[] audio data through any developer-assigned AudioSource"
    - "Ring buffer bridges main-thread writes and audio-thread reads without locks"
    - "24kHz Gemini audio is resampled to system sample rate via linear interpolation"
    - "Write-ahead watermark prevents pops, clicks, and silence gaps during streaming"
    - "AudioPlayback outputs silence on underrun and resumes when watermark is met again"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/AudioRingBuffer.cs"
      provides: "Thread-safe single-producer single-consumer ring buffer"
      contains: "class AudioRingBuffer"
    - path: "Packages/com.google.ai-embodiment/Runtime/AudioPlayback.cs"
      provides: "Streaming audio playback MonoBehaviour with OnAudioFilterRead"
      contains: "class AudioPlayback"
  key_links:
    - from: "AudioPlayback.cs"
      to: "AudioRingBuffer.cs"
      via: "AudioPlayback._ringBuffer field"
      pattern: "AudioRingBuffer"
    - from: "AudioPlayback.OnAudioFilterRead"
      to: "AudioRingBuffer.Read"
      via: "audio thread callback reads from ring buffer"
      pattern: "OnAudioFilterRead.*_ringBuffer"
    - from: "AudioPlayback.EnqueueAudio"
      to: "AudioRingBuffer.Write"
      via: "main thread method writes incoming audio"
      pattern: "EnqueueAudio.*Write"
---

<objective>
Create the AudioRingBuffer utility and AudioPlayback MonoBehaviour for streaming AI voice playback through Unity AudioSource.

Purpose: This is the technically hardest component in Phase 2 -- bridging Unity's audio thread (OnAudioFilterRead at system sample rate) with main-thread audio data arrival from Gemini (24kHz mono). Getting the ring buffer, resampling, and watermark right here prevents all downstream audio quality issues.

Output: Two new C# files providing lock-free ring buffer and streaming playback component ready for PersonaSession integration in Plan 02-03.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audio-pipeline/02-RESEARCH.md
@.planning/phases/02-audio-pipeline/02-CONTEXT.md
@Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: AudioRingBuffer -- thread-safe single-producer single-consumer ring buffer</name>
  <files>Packages/com.google.ai-embodiment/Runtime/AudioRingBuffer.cs</files>
  <action>
Create `AudioRingBuffer.cs` in namespace `AIEmbodiment`.

This is a lock-free single-producer single-consumer circular buffer for float audio samples. Main thread writes, audio thread reads.

**Class: `AudioRingBuffer`**
- Constructor takes `int capacity`
- `_buffer`: float array of size `capacity`
- `_writePos` and `_readPos`: volatile int (single-producer single-consumer means volatile is sufficient, no locks)
- `_capacity`: readonly int

**Public API:**
- `int Available { get; }` -- returns `(_writePos - _readPos + _capacity) % _capacity`
- `void Write(float[] data, int offset, int count)` -- copies samples into circular buffer, advances `_writePos`. Caller is always main thread.
- `int Read(float[] data, int offset, int count)` -- reads up to `count` samples (or less if not available), zero-fills remainder if underrun, advances `_readPos`. Returns number of actual samples read. Caller is always audio thread.
- `void Clear()` -- resets `_readPos = _writePos` (used on interruption to flush stale audio)

**Important details from RESEARCH.md:**
- No allocations in Read -- audio thread has real-time deadline (~21ms at 48kHz)
- Write wraps around the buffer using modulo arithmetic
- Read wraps around the buffer using modulo arithmetic
- Zero-fill on underrun (output silence, don't output stale data)

**Do NOT:**
- Use locks, Mutex, Monitor, or Interlocked -- volatile int is correct for SPSC
- Allocate any arrays in Read or Write -- only index arithmetic and array access
- Use LINQ anywhere in this class
  </action>
  <verify>
Open the file and verify:
1. Class compiles (check for syntax errors by reading)
2. volatile int for _writePos and _readPos
3. No lock/Monitor/Mutex usage
4. Write and Read use modulo wrap-around
5. Read zero-fills remaining samples on underrun
6. Clear resets read position to write position
  </verify>
  <done>AudioRingBuffer.cs exists with thread-safe Write, Read, Available, and Clear operations using volatile int positions and zero-allocation read path</done>
</task>

<task type="auto">
  <name>Task 2: AudioPlayback -- streaming playback MonoBehaviour with OnAudioFilterRead and resampling</name>
  <files>Packages/com.google.ai-embodiment/Runtime/AudioPlayback.cs</files>
  <action>
Create `AudioPlayback.cs` in namespace `AIEmbodiment`. This MonoBehaviour sits on the same GameObject as (or any GameObject with) an AudioSource and streams Gemini audio through it.

**Fields:**
- `[SerializeField] AudioSource _audioSource` -- developer assigns in Inspector (CONTEXT.md: "Developer can assign any AudioSource")
- `private AudioRingBuffer _ringBuffer`
- `private const int GEMINI_SAMPLE_RATE = 24000`
- `private const int BUFFER_SECONDS = 2` -- ring buffer holds 2 seconds of 24kHz audio = 48000 samples
- `private const float WATERMARK_SECONDS = 0.15f` -- 150ms write-ahead watermark
- `private int _watermarkSamples`
- `private double _resampleRatio` -- `GEMINI_SAMPLE_RATE / (double)systemRate`
- `private bool _isBuffering` -- true when underrun detected, cleared when watermark met
- `private float _resamplePosition` -- fractional position tracking in source audio for resampling continuity across OnAudioFilterRead calls
- `private float[] _resampleBuffer` -- pre-allocated temp buffer for reading from ring buffer before resampling (size = max source samples needed per callback)

**Public API:**
- `void Initialize()` -- called once when PersonaSession wires up audio. Queries `AudioSettings.outputSampleRate`, computes `_resampleRatio`, allocates `_ringBuffer` (capacity = `GEMINI_SAMPLE_RATE * BUFFER_SECONDS`), computes `_watermarkSamples`, pre-allocates `_resampleBuffer`. Creates a 1-second silent dummy AudioClip, assigns to `_audioSource`, sets `loop = true`, calls `Play()` so OnAudioFilterRead fires (Research Pitfall 8).
- `void EnqueueAudio(float[] samples)` -- called from main thread. Writes samples to `_ringBuffer`.
- `void ClearBuffer()` -- called from main thread on interruption. Calls `_ringBuffer.Clear()`, sets `_isBuffering = true`, resets `_resamplePosition = 0`.
- `void Stop()` -- called on disconnect. Stops AudioSource, clears ring buffer.
- `bool IsPlaying { get; }` -- returns true if ring buffer has audio data (available > 0 or not buffering). Useful for PersonaSession to know when AI audio has finished draining.

**OnAudioFilterRead(float[] data, int channels):**
This is the critical audio-thread method. ZERO allocations allowed. No Unity API calls. No LINQ.

1. If `_ringBuffer == null`, clear data to zeros, return.
2. Calculate how many source samples (at 24kHz) are needed for this output buffer: `int outputSamples = data.Length / channels`. The number of 24kHz source samples consumed depends on resampling.
3. If `_isBuffering` and `_ringBuffer.Available < _watermarkSamples`: clear data to zeros, return (stay in buffering state).
4. If `_isBuffering` and `_ringBuffer.Available >= _watermarkSamples`: set `_isBuffering = false` (resume playback).
5. Calculate source samples needed: `int sourceSamplesNeeded = (int)Math.Ceiling(outputSamples * _resampleRatio) + 2` (the +2 is for interpolation lookahead).
6. Read `sourceSamplesNeeded` samples from ring buffer into pre-allocated `_resampleBuffer`.
7. If ring buffer returned 0 actual samples: enter buffering state (`_isBuffering = true`), clear data to zeros, return.
8. Linear interpolation resampling: For each output sample index `i`, compute `double srcPos = _resamplePosition + i * _resampleRatio`. Get `int idx0 = (int)srcPos` and `int idx1 = idx0 + 1`. Clamp to available data. Compute `float frac = (float)(srcPos - idx0)`. Interpolated sample = `_resampleBuffer[idx0] * (1f - frac) + _resampleBuffer[idx1] * frac`. Write to all channels: `data[i * channels + ch] = sample`.
9. After the loop, update `_resamplePosition` for continuity: advance by `outputSamples * _resampleRatio`, subtract the integer samples consumed.

**Important from RESEARCH.md:**
- MUST create dummy silent AudioClip and call Play() or OnAudioFilterRead never fires (Pitfall 8)
- MUST resample from 24kHz to system rate or audio plays at wrong pitch (Pitfall 1)
- MUST pre-allocate all buffers in Initialize -- zero allocation in OnAudioFilterRead (Pitfall 4)
- Ring buffer sized for 2 seconds absorbs network jitter; 150ms watermark absorbs packet jitter (Ring Buffer Design section)
- Output mono sample to all channels -- AudioSource spatial blend handles the rest (Open Question 2)

**Do NOT:**
- Use `new` keyword in OnAudioFilterRead
- Call any Unity API in OnAudioFilterRead (only array access and arithmetic)
- Use async/await in OnAudioFilterRead
- Make AudioPlayback responsible for mic capture -- that's AudioCapture's job
  </action>
  <verify>
Open the file and verify:
1. OnAudioFilterRead has ZERO `new` keyword usage, ZERO Unity API calls, ZERO LINQ
2. Initialize creates dummy AudioClip and calls Play
3. _resampleRatio computed as GEMINI_SAMPLE_RATE / (double)systemRate
4. Linear interpolation resampling in OnAudioFilterRead
5. Watermark check: buffering state entered on underrun, exited when watermark met
6. ClearBuffer resets ring buffer and resampling state
7. _audioSource is SerializeField for Inspector assignment
  </verify>
  <done>AudioPlayback.cs exists as a MonoBehaviour with Initialize, EnqueueAudio, ClearBuffer, Stop. OnAudioFilterRead performs lock-free ring buffer reads with linear interpolation resampling from 24kHz to system rate, watermark-based underrun handling, and zero allocations on the audio thread.</done>
</task>

</tasks>

<verification>
- AudioRingBuffer.cs has correct SPSC ring buffer semantics (volatile positions, modulo wrap, zero-fill underrun)
- AudioPlayback.cs has OnAudioFilterRead with linear interpolation resampling and watermark buffering
- No file conflicts with Plan 02-02 (AudioCapture) -- these are independent new files
- No modifications to existing files -- PersonaSession integration deferred to Plan 02-03
</verification>

<success_criteria>
- AudioRingBuffer.cs and AudioPlayback.cs exist in Packages/com.google.ai-embodiment/Runtime/
- Ring buffer is lock-free with volatile int positions
- OnAudioFilterRead resamples 24kHz source to system sample rate via linear interpolation
- Watermark prevents playback before sufficient buffering
- All buffers pre-allocated in Initialize -- zero allocation on audio thread
- AudioSource is assignable via Inspector SerializeField
</success_criteria>

<output>
After completion, create `.planning/phases/02-audio-pipeline/02-01-SUMMARY.md`
</output>
