---
phase: 03-synchronization
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
autonomous: true

must_haves:
  truths:
    - "PersonaSession fires OnSyncPacket events with correlated text, audio, and turn info"
    - "Existing events (OnTextReceived, OnTurnComplete, OnOutputTranscription, etc.) still fire unchanged"
    - "Output transcript text streams incrementally as chunks arrive (TRNS-02, TRNS-03)"
    - "PacketAssembler receives audio chunks, output transcription, turn complete, and interrupted signals from ProcessResponse"
    - "PacketAssembler starts a new turn when first audio or transcription arrives after idle or after previous turn ends"
    - "Barge-in interruption cancels the current assembler turn and clears audio playback buffer"
    - "PacketAssembler is reset on disconnect for clean teardown"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs"
      provides: "OnSyncPacket event, PacketAssembler integration in ProcessResponse, incremental transcript streaming"
      contains: "OnSyncPacket"
  key_links:
    - from: "PersonaSession.cs"
      to: "PacketAssembler.cs"
      via: "owns PacketAssembler instance, routes ProcessResponse data to it"
      pattern: "_packetAssembler\\.Add"
    - from: "PersonaSession.cs"
      to: "SyncPacket.cs"
      via: "OnSyncPacket event signature uses SyncPacket type"
      pattern: "event Action<SyncPacket> OnSyncPacket"
    - from: "ProcessResponse"
      to: "PacketAssembler.AddTranscription"
      via: "MainThreadDispatcher.Enqueue routes OutputTranscription text"
      pattern: "Enqueue.*AddTranscription"
    - from: "ProcessResponse"
      to: "PacketAssembler.AddAudio"
      via: "MainThreadDispatcher.Enqueue routes AudioAsFloat chunks"
      pattern: "Enqueue.*AddAudio"
---

<objective>
Wire PacketAssembler into PersonaSession so that ProcessResponse routes text, audio, and events through the assembler, firing a new OnSyncPacket event alongside all existing events (backward compatible).

Purpose: This connects the synchronization layer to the live data stream, completing the developer-facing unified packet API. After this plan, developers subscribe to one event and get correlated subtitles + audio + function calls.

Output: Modified PersonaSession.cs with PacketAssembler field, OnSyncPacket event, and ProcessResponse routing additions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-synchronization/03-CONTEXT.md
@.planning/phases/03-synchronization/03-RESEARCH.md
@.planning/phases/03-synchronization/03-01-SUMMARY.md
@Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
@Packages/com.google.ai-embodiment/Runtime/PacketAssembler.cs
@Packages/com.google.ai-embodiment/Runtime/SyncPacket.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PacketAssembler field, OnSyncPacket event, and RegisterSyncDriver to PersonaSession</name>
  <files>Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs</files>
  <action>
Add the following to PersonaSession (do NOT remove or rename any existing fields, events, or methods):

**New field:**
- `private PacketAssembler _packetAssembler;` -- alongside existing private fields

**New event:**
- `public event Action<SyncPacket> OnSyncPacket;` -- alongside existing events, with XML doc: "Fires with correlated text, audio, and function call data packaged into SyncPackets. Subscribe to this for synchronized subtitles, audio, and event handling."

**New public method:**
- `public void RegisterSyncDriver(ISyncDriver driver)` -- delegates to `_packetAssembler.RegisterSyncDriver(driver)`. Add guard: if _packetAssembler is null, log warning and return. XML doc: "Registers a sync driver that controls packet release timing. The highest-latency driver wins."

**In Connect(), after `SetState(SessionState.Connected)` and before `_audioPlayback?.Initialize()`:**
- Create the PacketAssembler: `_packetAssembler = new PacketAssembler();`
- Wire the callback: `_packetAssembler.SetPacketCallback(packet => OnSyncPacket?.Invoke(packet));`

**In Disconnect(), after stopping audio components and before closing the live session:**
- Reset the assembler: `_packetAssembler?.Reset(); _packetAssembler = null;`

**In OnDestroy(), alongside existing cleanup:**
- Add `_packetAssembler?.Reset();` before the CTS cancel
  </action>
  <verify>
Read PersonaSession.cs and verify:
- `_packetAssembler` field exists
- `OnSyncPacket` event exists with Action<SyncPacket> signature
- `RegisterSyncDriver` public method exists
- PacketAssembler created in Connect() with callback wired to OnSyncPacket
- PacketAssembler reset in Disconnect() and OnDestroy()
- ALL existing events still present (OnStateChanged, OnTextReceived, OnTurnComplete, OnInputTranscription, OnOutputTranscription, OnInterrupted, OnAISpeakingStarted, OnAISpeakingStopped, OnUserSpeakingStarted, OnUserSpeakingStopped, OnError)
  </verify>
  <done>
PersonaSession owns a PacketAssembler instance created on Connect, fires OnSyncPacket from the assembler callback, exposes RegisterSyncDriver for future driver registration, and cleans up the assembler on disconnect and destroy. All existing events remain untouched.
  </done>
</task>

<task type="auto">
  <name>Task 2: Route ProcessResponse data through PacketAssembler</name>
  <files>Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs</files>
  <action>
Modify the ProcessResponse method to ADD PacketAssembler routing alongside (not replacing) existing event dispatch. The existing event firing code stays exactly as-is. New code is ADDED to route data to the assembler.

**Audio routing -- inside the `if (audioChunks != null && audioChunks.Count > 0)` block:**
After the existing AudioPlayback routing and speaking state tracking, add assembler routing:
```csharp
// Route audio to PacketAssembler (via main thread) for sync packets
foreach (var chunk in audioChunks)
{
    var localChunk = chunk;
    MainThreadDispatcher.Enqueue(() => _packetAssembler?.AddAudio(localChunk));
}
```

IMPORTANT: Do NOT gate the assembler routing on `_audioPlayback != null`. The PacketAssembler must receive audio regardless of whether AudioPlayback is assigned. The existing AudioPlayback routing stays inside its null check. The assembler routing is outside that check but still inside the `audioChunks.Count > 0` check.

**Turn start detection -- at the START of the audio routing block and the output transcription block:**
The assembler needs to know when a turn starts. Add a `_turnStarted` boolean field (private, alongside `_aiSpeaking`). Set it to `false` in ProcessResponse when TurnComplete or Interrupted is received (after the existing event dispatch). Before routing audio or output transcription to the assembler, check:
```csharp
if (!_turnStarted)
{
    _turnStarted = true;
    MainThreadDispatcher.Enqueue(() => _packetAssembler?.StartTurn());
}
```
This ensures StartTurn is called exactly once per AI response turn, on the first data chunk.

**Output transcription routing -- inside the `if (content.OutputTranscription.HasValue)` block:**
After the existing `OnOutputTranscription` event firing, add:
```csharp
// Route to PacketAssembler for sentence-boundary subtitle packets
string transcriptForAssembler = transcript; // capture for lambda
MainThreadDispatcher.Enqueue(() => _packetAssembler?.AddTranscription(transcriptForAssembler));
```
This implements TRNS-02 (output transcript via event) which was already done in Phase 2, and TRNS-03 (incremental streaming) which the assembler delivers via OnSyncPacket.

**TurnComplete routing -- inside the `if (content.TurnComplete)` block:**
After the existing speaking state and OnTurnComplete event firing, add:
```csharp
_turnStarted = false;
MainThreadDispatcher.Enqueue(() => _packetAssembler?.FinishTurn());
```

**Interrupted routing -- inside the `if (content.Interrupted)` block:**
After the existing AudioPlayback.ClearBuffer and event firing, add:
```csharp
_turnStarted = false;
MainThreadDispatcher.Enqueue(() => _packetAssembler?.CancelTurn());
```

**Tool call routing -- in the `else if (response.Message is LiveSessionToolCall)` block:**
Replace the existing Debug.Log stub with:
```csharp
else if (response.Message is LiveSessionToolCall toolCall)
{
    // Route function calls to PacketAssembler (Phase 4 will fully implement handlers)
    if (toolCall.FunctionCalls != null)
    {
        foreach (var fc in toolCall.FunctionCalls)
        {
            var name = fc.Name;
            var args = fc.Args;
            var id = fc.Id;
            MainThreadDispatcher.Enqueue(() => _packetAssembler?.AddFunctionCall(name, args, id));
        }
    }
}
```
Note: `LiveSessionToolCall.FunctionCalls` returns a list of `FunctionCallPart` objects with `Name`, `Args` (IDictionary<string, object>), and `Id` properties. The `args` may need to be cast or wrapped as `IReadOnlyDictionary<string, object>` -- use `new Dictionary<string, object>(fc.Args)` if `fc.Args` is not already IReadOnlyDictionary, or a simple cast/wrapping as appropriate based on the SDK type.

**Critical constraints:**
- Do NOT remove or modify ANY existing event firing (OnTextReceived, OnAISpeakingStarted, etc.)
- Do NOT change the audio routing to AudioPlayback -- it stays as-is
- The null-safe `_packetAssembler?.` pattern ensures text-only sessions (no PacketAssembler) still work
- All new MainThreadDispatcher.Enqueue calls go AFTER existing event dispatch for the same data
  </action>
  <verify>
Read the full ProcessResponse method and verify:
- Audio chunks are routed to BOTH AudioPlayback (when assigned) AND PacketAssembler (always)
- OutputTranscription text is routed to BOTH OnOutputTranscription event AND PacketAssembler.AddTranscription
- TurnComplete calls PacketAssembler.FinishTurn and resets _turnStarted
- Interrupted calls PacketAssembler.CancelTurn and resets _turnStarted
- _turnStarted is set to true on first audio or transcription chunk of a turn
- LiveSessionToolCall routes function calls to PacketAssembler.AddFunctionCall
- ALL existing events still fire as before (backward compatibility)
- Null-safe access on _packetAssembler throughout
  </verify>
  <done>
ProcessResponse routes audio, transcription, turn complete, interrupted, and tool call data through PacketAssembler alongside all existing direct events. Turn start is detected on first data chunk per response. Existing backward-compatible events (OnTextReceived, OnOutputTranscription, OnAISpeakingStarted, etc.) all remain functional. TRNS-02 and TRNS-03 are satisfied through the existing OnOutputTranscription event (incremental) plus OnSyncPacket (sentence-boundary correlated with audio).
  </done>
</task>

</tasks>

<verification>
- PersonaSession.cs has OnSyncPacket event that fires SyncPackets from PacketAssembler
- All 11 existing events still present and functional (OnStateChanged, OnTextReceived, OnTurnComplete, OnInputTranscription, OnOutputTranscription, OnInterrupted, OnAISpeakingStarted, OnAISpeakingStopped, OnUserSpeakingStarted, OnUserSpeakingStopped, OnError)
- ProcessResponse routes audio/transcription/turnComplete/interrupted/toolCall through PacketAssembler
- PacketAssembler created on Connect, reset on Disconnect/OnDestroy
- No compilation errors
</verification>

<success_criteria>
- OnSyncPacket event fires SyncPackets with correlated text and audio at sentence boundaries
- Existing events are backward compatible (no breaks from Phase 1/2 API)
- Turn lifecycle: StartTurn on first data -> packets at sentence boundaries -> FinishTurn on TurnComplete
- Barge-in: CancelTurn clears assembler state, ClearBuffer clears audio playback (both happen)
- Tool calls produce FunctionCall-type SyncPackets with name, args, and ID
- Requirements addressed: SYNC-01, SYNC-02, SYNC-03 (Gemini path), TRNS-02, TRNS-03
</success_criteria>

<output>
After completion, create `.planning/phases/03-synchronization/03-02-SUMMARY.md`
</output>
