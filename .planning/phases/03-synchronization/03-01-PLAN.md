---
phase: 03-synchronization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/SyncPacket.cs
  - Packages/com.google.ai-embodiment/Runtime/ISyncDriver.cs
  - Packages/com.google.ai-embodiment/Runtime/PacketAssembler.cs
autonomous: true

must_haves:
  truths:
    - "SyncPacket carries correlated text, audio, and function call data with turn ID and sequence number"
    - "PacketAssembler buffers text at sentence boundaries and accumulates audio between emissions"
    - "PacketAssembler force-flushes remaining text and audio when a turn completes"
    - "PacketAssembler clears all buffers when a turn is cancelled (barge-in)"
    - "ISyncDriver interface exists for future sync timing control (Chirp TTS, Face Animation)"
    - "When no sync driver is registered, packets release immediately (Gemini native audio path)"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/SyncPacket.cs"
      provides: "SyncPacket readonly struct and SyncPacketType enum"
      contains: "readonly struct SyncPacket"
    - path: "Packages/com.google.ai-embodiment/Runtime/ISyncDriver.cs"
      provides: "ISyncDriver interface for pluggable sync timing control"
      contains: "interface ISyncDriver"
    - path: "Packages/com.google.ai-embodiment/Runtime/PacketAssembler.cs"
      provides: "PacketAssembler class with sentence boundary buffering, audio accumulation, turn lifecycle"
      contains: "class PacketAssembler"
  key_links:
    - from: "PacketAssembler.cs"
      to: "SyncPacket.cs"
      via: "emits SyncPacket instances through callback"
      pattern: "new SyncPacket"
    - from: "PacketAssembler.cs"
      to: "ISyncDriver.cs"
      via: "routes packets through driver if registered, otherwise immediate release"
      pattern: "_syncDriver.*OnPacketReady"
---

<objective>
Create the SyncPacket data model, ISyncDriver interface, and PacketAssembler class that buffers incoming text and audio from Gemini Live into correlated sentence-boundary packets.

Purpose: This is the core synchronization layer that converts scatter-shot text/audio/event data into unified developer-facing packets. Without it, developers must manually correlate independent data streams.

Output: Three new C# files in the Runtime directory -- SyncPacket.cs (data type), ISyncDriver.cs (timing interface), PacketAssembler.cs (assembly logic).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-synchronization/03-CONTEXT.md
@.planning/phases/03-synchronization/03-RESEARCH.md
@Packages/com.google.ai-embodiment/Runtime/AudioPlayback.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SyncPacket readonly struct and ISyncDriver interface</name>
  <files>
    Packages/com.google.ai-embodiment/Runtime/SyncPacket.cs
    Packages/com.google.ai-embodiment/Runtime/ISyncDriver.cs
  </files>
  <action>
Create two new C# files in the AIEmbodiment namespace:

**SyncPacket.cs:**
- Define `SyncPacketType` enum with two values: `TextAudio` and `FunctionCall`
- Define `SyncPacket` as a `readonly struct` with a constructor that sets all fields:
  - `SyncPacketType Type` -- discriminates content type
  - `int TurnId` -- groups packets within one AI response turn
  - `int Sequence` -- 0-based ascending order within a turn
  - `string Text` -- subtitle text for TextAudio packets (empty string for FunctionCall)
  - `float[] Audio` -- PCM audio at 24kHz mono for TextAudio packets (null for FunctionCall)
  - `string FunctionName` -- function name for FunctionCall packets (empty string for TextAudio)
  - `IReadOnlyDictionary<string, object> FunctionArgs` -- function args for FunctionCall packets (null for TextAudio)
  - `string FunctionId` -- function call ID for response correlation (null for TextAudio)
  - `bool IsTurnEnd` -- true if this is the last packet in the turn
- All properties are get-only (init via constructor)
- Add XML doc comments on every public member
- Use `System.Collections.Generic` for IReadOnlyDictionary

**ISyncDriver.cs:**
- Define `ISyncDriver` interface with three members:
  - `void OnPacketReady(SyncPacket packet)` -- called when a packet is assembled and ready for release; driver may hold it
  - `void SetReleaseCallback(Action<SyncPacket> releaseCallback)` -- driver calls this callback when releasing packets
  - `int EstimatedLatencyMs { get; }` -- pipeline latency for highest-latency-wins selection
- Add XML doc comments explaining the pluggable driver model (Chirp TTS, Face Animation use cases)
- Use `System` namespace for Action

Follow the research Pattern 1 (SyncPacket as Readonly Struct) and Pattern 4 (ISyncDriver Interface) exactly. These are pure data types with no Unity dependencies.
  </action>
  <verify>
Confirm files exist and compile:
- `cat Packages/com.google.ai-embodiment/Runtime/SyncPacket.cs` -- verify readonly struct with all 9 properties
- `cat Packages/com.google.ai-embodiment/Runtime/ISyncDriver.cs` -- verify interface with 3 members
- Both files are in the `AIEmbodiment` namespace
- No Unity-specific imports (these are pure C# types)
  </verify>
  <done>
SyncPacket readonly struct has Type, TurnId, Sequence, Text, Audio, FunctionName, FunctionArgs, FunctionId, IsTurnEnd properties. ISyncDriver interface has OnPacketReady, SetReleaseCallback, EstimatedLatencyMs members. Both compile as part of the com.google.ai-embodiment assembly.
  </done>
</task>

<task type="auto">
  <name>Task 2: PacketAssembler with sentence boundary buffering and audio accumulation</name>
  <files>
    Packages/com.google.ai-embodiment/Runtime/PacketAssembler.cs
  </files>
  <action>
Create PacketAssembler as a plain C# class (NOT MonoBehaviour) in the AIEmbodiment namespace. It receives raw events, buffers them, and emits SyncPackets at sentence boundaries.

**Public API:**
- `void SetPacketCallback(Action<SyncPacket> callback)` -- register the callback that receives assembled packets
- `void RegisterSyncDriver(ISyncDriver driver)` -- register an optional sync driver for timing control
- `void StartTurn()` -- begin a new turn (increments turn ID, resets sequence counter and buffers)
- `void AddTranscription(string text)` -- append output transcription text and attempt sentence boundary flush
- `void AddAudio(float[] samples)` -- accumulate audio chunk into pending list
- `void AddFunctionCall(string name, IReadOnlyDictionary<string, object> args, string id)` -- emit a FunctionCall-type SyncPacket immediately (stub for Phase 4; emit it right away with current turn ID)
- `void FinishTurn()` -- force-flush ALL remaining buffered text and audio as a final packet with IsTurnEnd=true, then mark turn inactive
- `void CancelTurn()` -- clear all buffers (text, audio, sentence state) without emitting; used on barge-in interruption
- `void Reset()` -- full reset: clear buffers, reset turn counter to 0, used on disconnect

**Internal state:**
- `int _nextTurnId` and `int _currentTurnId` for turn tracking
- `int _sequence` for packet ordering within a turn
- `bool _turnActive` flag
- `StringBuilder _textBuffer` for accumulating transcription text
- `int _textCursor` tracking position of last emitted text in the buffer
- `List<float[]> _pendingAudio` for accumulating audio chunks between emissions
- `float _lastFlushTime` and constants `FlushTimeoutSeconds = 0.5f`, `MinFlushChars = 20` for time-based fallback

**Sentence boundary detection:**
Implement `FindSentenceBoundary(string text, int startIndex)` as a private static method returning the index past the last sentence-ending punctuation (`.`, `?`, `!`) that is followed by whitespace or end-of-string. Return -1 if no boundary found. This handles "3.14" and "U.S.A" correctly by requiring whitespace after punctuation.

**TryFlush logic (called from AddTranscription):**
1. Convert buffer to string, look for sentence boundary after _textCursor
2. If boundary found: extract text from _textCursor to boundary, merge pending audio, emit TextAudio packet, advance _textCursor, update _lastFlushTime
3. Else if Time.time - _lastFlushTime >= 0.5f AND buffered chars >= 20: find last space for word boundary flush
4. No boundary and no timeout: do nothing (wait for more data)

**EmitTextAudioPacket:**
- Call MergeAudioChunks() to combine all pending float[] arrays into a single float[] (or null if no audio pending)
- Create SyncPacket with TextAudio type, current turn/sequence, trimmed text, merged audio, isTurnEnd=false
- Increment sequence
- Call ReleasePacket

**MergeAudioChunks:**
- If _pendingAudio is empty, return null
- Sum all chunk lengths, allocate new float[], Array.Copy each chunk into it
- Clear _pendingAudio list
- Return merged array

**ReleasePacket:**
- If _syncDriver is not null, call _syncDriver.OnPacketReady(packet)
- Else call _packetCallback directly (immediate release for Gemini native path)

**FlushAll (called from FinishTurn):**
- If any text remains after _textCursor OR any audio pending: emit one final TextAudio packet with IsTurnEnd=true
- Clear buffers

**Important constraints:**
- PacketAssembler is a plain C# class, NOT a MonoBehaviour
- It runs entirely on the main thread (no thread safety needed internally)
- It uses `UnityEngine.Time.time` only in TryFlush for the timeout fallback -- this is the sole Unity dependency
- Use `System.Text.StringBuilder` for text buffering (avoids O(n^2) string concatenation)
- Follow research Example 1 (PacketAssembler Core Flow) closely
  </action>
  <verify>
Confirm file exists and contains all required methods:
- `cat Packages/com.google.ai-embodiment/Runtime/PacketAssembler.cs`
- Verify public methods: SetPacketCallback, RegisterSyncDriver, StartTurn, AddTranscription, AddAudio, AddFunctionCall, FinishTurn, CancelTurn, Reset
- Verify FindSentenceBoundary is private static with punctuation + whitespace check
- Verify MergeAudioChunks merges List of float[] into single float[]
- Verify ReleasePacket routes through _syncDriver if present, else direct callback
- Verify class is in AIEmbodiment namespace and is NOT a MonoBehaviour
  </verify>
  <done>
PacketAssembler class buffers transcription text at sentence boundaries (. ? ! + whitespace, with 500ms/20-char time-based fallback), accumulates audio chunks between sentence emissions, merges audio into single arrays per packet, handles turn lifecycle (start/finish/cancel/reset), and routes SyncPackets through optional ISyncDriver or directly to callback. Function call stub emits FunctionCall packets immediately.
  </done>
</task>

</tasks>

<verification>
- SyncPacket.cs defines readonly struct with SyncPacketType enum
- ISyncDriver.cs defines interface with OnPacketReady, SetReleaseCallback, EstimatedLatencyMs
- PacketAssembler.cs is a plain C# class with sentence boundary buffering, audio accumulation, turn lifecycle
- All three files are in the AIEmbodiment namespace
- No compilation errors in the com.google.ai-embodiment assembly
</verification>

<success_criteria>
- Three new files exist in Packages/com.google.ai-embodiment/Runtime/
- SyncPacket has all 9 properties as readonly struct
- ISyncDriver has 3 interface members
- PacketAssembler has 8 public methods and sentence boundary detection
- PacketAssembler routes through ISyncDriver when registered, immediate callback when not
- CancelTurn clears all buffers without emitting
- FinishTurn force-flushes remaining data with IsTurnEnd=true
</success_criteria>

<output>
After completion, create `.planning/phases/03-synchronization/03-01-SUMMARY.md`
</output>
