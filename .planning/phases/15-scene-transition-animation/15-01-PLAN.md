---
phase: 15-scene-transition-animation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Assets/AyaLiveStream/AnimationConfig.cs
  - Assets/AyaLiveStream/AyaSampleController.cs
  - Assets/AyaLiveStream/LivestreamUI.cs
  - Assets/AyaLiveStream/UI/LivestreamPanel.uxml
  - Assets/AyaLiveStream/UI/LivestreamPanel.uss
autonomous: true

must_haves:
  truths:
    - "Aya triggers animation function calls (wave, point, laugh, think, nod) naturally during conversation"
    - "Animation triggers produce visible feedback -- Debug.Log in console AND toast message in the livestream UI"
    - "AnimationConfig ScriptableObject is editable in Inspector -- developers add/remove animations without code changes"
    - "Function registration uses a single play_animation function with enum parameter (not one function per animation)"
    - "Toast message auto-dismisses after 3 seconds and handles overlapping triggers correctly"
  artifacts:
    - path: "Assets/AyaLiveStream/AnimationConfig.cs"
      provides: "ScriptableObject defining available animations (name + description pairs)"
      exports: ["AnimationConfig", "AnimationConfig.AnimationEntry"]
      contains: "CreateAssetMenu"
      min_lines: 20
    - path: "Assets/AyaLiveStream/AyaSampleController.cs"
      provides: "Data-driven play_animation registration from AnimationConfig, toast-based handler"
      contains: "play_animation"
    - path: "Assets/AyaLiveStream/LivestreamUI.cs"
      provides: "ShowToast method with auto-dismiss and overlap guard"
      contains: "ShowToast"
    - path: "Assets/AyaLiveStream/UI/LivestreamPanel.uxml"
      provides: "Toast Label element in UI tree"
      contains: "toast-label"
    - path: "Assets/AyaLiveStream/UI/LivestreamPanel.uss"
      provides: "Toast styles with opacity transition"
      contains: "toast-label"
  key_links:
    - from: "AyaSampleController.cs"
      to: "AnimationConfig.GetAnimationNames()"
      via: "reading animation names for FunctionDeclaration.AddEnum"
      pattern: "GetAnimationNames"
    - from: "AyaSampleController.cs"
      to: "PersonaSession.RegisterFunction"
      via: "registering play_animation with enum parameter"
      pattern: "RegisterFunction.*play_animation"
    - from: "AyaSampleController.cs"
      to: "LivestreamUI.ShowToast"
      via: "handler calls toast on animation trigger"
      pattern: "ShowToast"
    - from: "LivestreamUI.cs"
      to: "toast-label element in UXML"
      via: "Q<Label> binding in OnEnable"
      pattern: "Q<Label>.*toast-label"
---

<objective>
Create the animation function call system: an AnimationConfig ScriptableObject defining available animations, data-driven registration as a single play_animation function with enum parameter, a toast notification in the LivestreamUI for visible feedback, and the handler wiring in AyaSampleController that replaces the existing hardcoded emote registration.

Purpose: Enables Gemini to trigger character animations during conversation, with visible toast feedback that developers can replace with actual Animator calls when they have a 3D model. This fulfills ANI-01.

Output: AnimationConfig.cs ScriptableObject, modified AyaSampleController.cs with data-driven registration, modified LivestreamUI.cs with ShowToast, modified UXML/USS with toast element and styles.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-scene-transition-animation/15-CONTEXT.md
@.planning/phases/15-scene-transition-animation/15-RESEARCH.md
@Assets/AyaLiveStream/AyaSampleController.cs
@Assets/AyaLiveStream/LivestreamUI.cs
@Assets/AyaLiveStream/ChatBotConfig.cs
@Assets/AyaLiveStream/UI/LivestreamPanel.uxml
@Assets/AyaLiveStream/UI/LivestreamPanel.uss
@Packages/com.google.ai-embodiment/Runtime/FunctionDeclaration.cs
@Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: AnimationConfig ScriptableObject and data-driven function registration</name>
  <files>
    Assets/AyaLiveStream/AnimationConfig.cs
    Assets/AyaLiveStream/AyaSampleController.cs
  </files>
  <action>
**1. Create AnimationConfig.cs** in the AIEmbodiment.Samples namespace, following the ChatBotConfig ScriptableObject pattern:

```csharp
[CreateAssetMenu(fileName = "AnimationConfig", menuName = "AI Embodiment/Samples/Animation Config")]
public class AnimationConfig : ScriptableObject
{
    [Serializable]
    public class AnimationEntry
    {
        [Tooltip("Animation name passed to function call (e.g. 'wave').")]
        public string name;

        [Tooltip("Description for Gemini to understand when to use this animation.")]
        [TextArea(1, 2)]
        public string description;
    }

    [Header("Available Animations")]
    [Tooltip("Animations Aya can trigger via function calls.")]
    public AnimationEntry[] animations;

    public string[] GetAnimationNames()
    {
        if (animations == null) return Array.Empty<string>();
        var names = new string[animations.Length];
        for (int i = 0; i < animations.Length; i++)
            names[i] = animations[i].name;
        return names;
    }
}
```

**2. Modify AyaSampleController.cs** to replace the hardcoded emote/start_movie/start_drawing registrations with data-driven animation registration:

Add a serialized field:
```csharp
[SerializeField] private AnimationConfig _animationConfig;
```

Also ensure there is a reference to LivestreamUI (check if it exists; if not, add it):
```csharp
[SerializeField] private LivestreamUI _livestreamUI;
```

Replace the entire body of `RegisterFunctions()` with:
```csharp
private void RegisterFunctions()
{
    // Animation function -- data-driven from ScriptableObject
    if (_animationConfig != null && _animationConfig.animations != null
        && _animationConfig.animations.Length > 0)
    {
        string[] animNames = _animationConfig.GetAnimationNames();
        var animDecl = new FunctionDeclaration(
                "play_animation",
                "Play a character animation or gesture during conversation. Use this to add expressiveness.")
            .AddEnum("animation_name", "Name of the animation to play", animNames);
        _session.RegisterFunction("play_animation", animDecl, HandlePlayAnimation);
    }
    else
    {
        Debug.LogWarning("[AyaSampleController] No AnimationConfig assigned or empty -- animation function calls disabled.");
    }
}
```

Replace the existing `HandleEmote`, `HandleStartMovie`, and `HandleStartDrawing` methods with a single handler:
```csharp
private IDictionary<string, object> HandlePlayAnimation(FunctionCallContext ctx)
{
    string animName = ctx.GetString("animation_name", "idle");
    Debug.Log($"[Animation] play_animation triggered: {animName}");
    _livestreamUI?.ShowToast($"*{animName}*");
    return null; // fire-and-forget
}
```

Remove the old HandleEmote, HandleStartMovie, and HandleStartDrawing methods entirely. Remove the HandleFunctionError reference to _chatUI.LogSystemMessage if _chatUI is the old AyaChatUI -- replace with Debug.Log or _livestreamUI?.ShowToast if appropriate. Keep the HandleFunctionError method but use Debug.LogError instead of _chatUI reference if _chatUI is an old panel.

IMPORTANT: Do NOT remove or change the existing Start() flow (RegisterFunctions called before Connect), OnDestroy cleanup, Update PTT handling, HandleTurnComplete goal logic, HandleStateChanged, HandleSyncPacket, or PlayIntroThenGoLive coroutine. Only modify RegisterFunctions() and its associated handlers.

IMPORTANT: Keep the _chatUI field and all references to it if they still exist and compile. The old AyaChatUI may still be referenced elsewhere. Only remove handlers that are being replaced (HandleEmote, HandleStartMovie, HandleStartDrawing).
  </action>
  <verify>
Both files compile. Verify: AnimationConfig.cs has CreateAssetMenu attribute, AnimationEntry with name+description, GetAnimationNames() method. AyaSampleController.cs has _animationConfig field, RegisterFunctions() uses FunctionDeclaration.AddEnum with animation names from config, HandlePlayAnimation calls Debug.Log and ShowToast. Old HandleEmote/HandleStartMovie/HandleStartDrawing methods are removed.
  </verify>
  <done>AnimationConfig ScriptableObject defines available animations in Inspector. AyaSampleController registers a single play_animation function with enum parameter from config data. Handler logs to console and calls ShowToast. Old hardcoded emote/start_movie/start_drawing registrations are replaced.</done>
</task>

<task type="auto">
  <name>Task 2: Toast notification UI in LivestreamUI with UXML/USS</name>
  <files>
    Assets/AyaLiveStream/LivestreamUI.cs
    Assets/AyaLiveStream/UI/LivestreamPanel.uxml
    Assets/AyaLiveStream/UI/LivestreamPanel.uss
  </files>
  <action>
**1. Add toast Label element to LivestreamPanel.uxml:**

Inside the `root-container` element, AFTER the `main-content` VisualElement (as the last child of root-container), add:
```xml
<!-- Toast notification for animation triggers -->
<ui:Label name="toast-label" text="" class="toast-label" />
```

**2. Add toast styles to LivestreamPanel.uss:**

Append these styles at the end of the file:
```css
/* Toast notification (animation triggers) */
.toast-label {
    position: absolute;
    bottom: 60px;
    left: 50%;
    translate: -50% 0;
    background-color: rgba(40, 40, 60, 0.9);
    color: rgb(200, 170, 255);
    padding: 8px 16px;
    border-radius: 6px;
    font-size: 14px;
    -unity-font-style: italic;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.toast--visible {
    opacity: 1;
}
```

**3. Add ShowToast method to LivestreamUI.cs:**

Add a private field:
```csharp
private Label _toastLabel;
private int _toastCounter;
```

In OnEnable(), after the existing Q<Label> bindings (after `_pttStatus = root.Q<Label>("ptt-status");`), add:
```csharp
_toastLabel = root.Q<Label>("toast-label");
```

Add the public method:
```csharp
/// <summary>
/// Shows a toast notification in the livestream UI. Auto-dismisses after the
/// specified duration. Handles overlapping calls correctly -- a newer toast
/// resets the dismiss timer without the older dismiss canceling it early.
/// </summary>
/// <param name="message">The text to display in the toast.</param>
/// <param name="duration">How long to show the toast in seconds (default 3).</param>
public async void ShowToast(string message, float duration = 3f)
{
    if (_toastLabel == null) return;

    _toastLabel.text = message;
    _toastLabel.AddToClassList("toast--visible");
    int myCounter = ++_toastCounter;

    try
    {
        await Awaitable.WaitForSecondsAsync(duration, destroyCancellationToken);
    }
    catch (OperationCanceledException) { return; }

    // Only dismiss if no newer toast has been shown
    if (_toastCounter == myCounter)
    {
        _toastLabel.RemoveFromClassList("toast--visible");
    }
}
```

Add the required using directive at the top of LivestreamUI.cs if not already present:
```csharp
using System.Threading;
```
(This may not be needed -- check if OperationCanceledException is already accessible via existing usings. It lives in System namespace which should already be imported via UnityEngine. If the file does not have `using System;`, add it.)

IMPORTANT: Do NOT modify any existing methods or fields. Only ADD the toast-related code.
  </action>
  <verify>
All three files are valid. Verify: LivestreamPanel.uxml contains a `toast-label` Label element as last child of root-container. LivestreamPanel.uss has `.toast-label` and `.toast--visible` classes with opacity transition. LivestreamUI.cs has `ShowToast(string message, float duration = 3f)` method with _toastCounter overlap guard and destroyCancellationToken usage. Existing methods unchanged.
  </verify>
  <done>Toast notification system works: ShowToast displays a message that fades in via CSS transition, auto-dismisses after 3 seconds, and handles overlapping triggers correctly via counter guard. Toast element exists in UXML tree and is styled with USS.</done>
</task>

</tasks>

<verification>
1. AnimationConfig.cs compiles in AIEmbodiment.Samples namespace with CreateAssetMenu attribute
2. AnimationConfig has AnimationEntry[] with name and description fields, GetAnimationNames() returns string[]
3. AyaSampleController.RegisterFunctions() creates a single play_animation FunctionDeclaration with AddEnum using names from AnimationConfig
4. HandlePlayAnimation calls Debug.Log AND LivestreamUI.ShowToast
5. Old HandleEmote, HandleStartMovie, HandleStartDrawing methods are removed
6. LivestreamPanel.uxml has toast-label Label element
7. LivestreamPanel.uss has .toast-label (opacity 0) and .toast--visible (opacity 1) with transition
8. LivestreamUI.ShowToast uses _toastCounter for overlap guard and destroyCancellationToken for safe async dismiss
9. All existing LivestreamUI methods untouched
10. RegisterFunctions() still called in Start() before Connect() (Pitfall 1 prevention)
</verification>

<success_criteria>
- AnimationConfig ScriptableObject is editable in Inspector (add/remove animation entries without code changes)
- AyaSampleController registers play_animation with enum parameter containing all config entries
- Animation trigger produces Debug.Log in console AND toast in UI
- Toast auto-dismisses after 3 seconds and handles rapid triggers without premature dismiss
- Old hardcoded function registrations (emote, start_movie, start_drawing) are replaced with data-driven approach
</success_criteria>

<output>
After completion, create `.planning/phases/15-scene-transition-animation/15-01-SUMMARY.md`
</output>
