---
phase: 08-personasession-migration-and-dependency-removal
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
autonomous: true

must_haves:
  truths:
    - "PersonaSession.Connect() establishes a session via GeminiLiveClient and transitions Connecting -> Connected"
    - "All existing public events fire with correct data (OnTextReceived, OnTurnComplete, OnStateChanged, OnInputTranscription, OnOutputTranscription, OnInterrupted, OnAISpeakingStarted/Stopped, OnUserSpeakingStarted/Stopped, OnError, OnSyncPacket)"
    - "SendText sends a text message via GeminiLiveClient.SendText"
    - "StartListening/StopListening capture and stream audio as PCM16 bytes via GeminiLiveClient.SendAudio"
    - "Disconnect performs synchronous GeminiLiveClient.Disconnect and cleans up resources"
    - "ProcessEvents is called in Update to drain GeminiLiveClient event queue"
    - "No MainThreadDispatcher wrapping for session event routing (events already on main thread)"
  artifacts:
    - path: "Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs"
      provides: "PersonaSession fully rewired to GeminiLiveClient"
      contains: "GeminiLiveClient"
      min_lines: 300
  key_links:
    - from: "PersonaSession.cs"
      to: "GeminiLiveClient"
      via: "_client field, OnEvent subscription, ProcessEvents in Update"
      pattern: "_client\\.ProcessEvents|_client\\.OnEvent"
    - from: "PersonaSession.cs"
      to: "AIEmbodimentSettings"
      via: "API key loaded in Connect()"
      pattern: "AIEmbodimentSettings\\.Instance"
    - from: "PersonaSession.cs HandleGeminiEvent"
      to: "GeminiEventType switch"
      via: "Event mapping from GeminiEvent to PersonaSession public events"
      pattern: "GeminiEventType\\."
    - from: "PersonaSession.cs HandleAudioCaptured"
      to: "GeminiLiveClient.SendAudio"
      via: "FloatToPcm16 conversion then SendAudio"
      pattern: "FloatToPcm16|_client\\.SendAudio"
---

<objective>
Rewire PersonaSession to use GeminiLiveClient instead of Firebase LiveSession, implementing the complete event bridge and audio pipeline.

Purpose: This is the core migration task. PersonaSession's entire internal implementation changes from Firebase's background-thread push model to GeminiLiveClient's main-thread poll model. The public API surface (events, methods, properties) stays identical so all downstream code (sample scene, developer integrations) continues to work.

Output: A fully functional PersonaSession.cs that connects via GeminiLiveClient, routes all events to the existing public API, handles audio capture/playback, and manages the session lifecycle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-personasession-migration-and-dependency-removal/08-CONTEXT.md
@.planning/phases/08-personasession-migration-and-dependency-removal/08-RESEARCH.md
@.planning/phases/08-personasession-migration-and-dependency-removal/08-01-SUMMARY.md
@Packages/com.google.ai-embodiment/Runtime/GeminiLiveClient.cs
@Packages/com.google.ai-embodiment/Runtime/GeminiEvent.cs
@Packages/com.google.ai-embodiment/Runtime/GeminiLiveConfig.cs
@Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs
@Packages/com.google.ai-embodiment/Runtime/PersonaConfig.cs
@Packages/com.google.ai-embodiment/Runtime/AIEmbodimentSettings.cs
@Packages/com.google.ai-embodiment/Runtime/PacketAssembler.cs
@Packages/com.google.ai-embodiment/Runtime/AudioPlayback.cs
@Packages/com.google.ai-embodiment/Runtime/AudioCapture.cs
@Packages/com.google.ai-embodiment/Runtime/FunctionRegistry.cs
@Packages/com.google.ai-embodiment/Runtime/FunctionCallContext.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite PersonaSession core lifecycle (Connect, Update, Disconnect, OnDestroy)</name>
  <files>Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs</files>
  <action>
    Replace the stubbed PersonaSession.cs with the full GeminiLiveClient-based implementation. This task covers the lifecycle methods; Task 2 covers event routing.

    **Imports:**
    - Remove any remaining `using Firebase.AI;`
    - Add `using Newtonsoft.Json.Linq;` (needed for FunctionCall args parsing)
    - Keep: System, System.Collections.Generic, System.Text, System.Threading, System.Threading.Tasks, UnityEngine

    **Field changes:**
    - Replace `private LiveSession _liveSession;` with `private GeminiLiveClient _client;`
    - All other fields remain the same (_config, _audioCapture, _audioPlayback, _sessionCts, _packetAssembler, _aiSpeaking, _turnStarted, _userSpeaking, _isListening, _chirpClient, _chirpTextBuffer, _chirpSynthesizing, _functionRegistry, _goalManager)

    **Add static helper method FloatToPcm16:**
    ```csharp
    private static byte[] FloatToPcm16(float[] samples)
    {
        byte[] pcm = new byte[samples.Length * 2];
        for (int i = 0; i < samples.Length; i++)
        {
            short s = (short)(Mathf.Clamp(samples[i], -1f, 1f) * 32767f);
            pcm[i * 2] = (byte)(s & 0xFF);
            pcm[i * 2 + 1] = (byte)((s >> 8) & 0xFF);
        }
        return pcm;
    }
    ```

    **Connect() rewrite:**
    1. Guard: if State != Disconnected, warn and return
    2. Guard: if _config == null, error and return
    3. Load API key: `var settings = AIEmbodimentSettings.Instance;` -- if null or ApiKey empty, log error with guidance message ("Create an AIEmbodimentSettings asset: Assets > Create > AI Embodiment > Settings, place it in a Resources folder, and set the API key.") and return
    4. SetState(Connecting)
    5. Create _sessionCts
    6. Build system instruction: `var systemInstruction = SystemInstructionBuilder.Build(_config, _goalManager);` (now returns string)
    7. Create GeminiLiveConfig:
       ```
       var liveConfig = new GeminiLiveConfig
       {
           ApiKey = settings.ApiKey,
           Model = _config.modelName,
           SystemInstruction = systemInstruction,
           VoiceName = _config.geminiVoiceName
       };
       ```
    8. Create client: `_client = new GeminiLiveClient(liveConfig);`
    9. Subscribe: `_client.OnEvent += HandleGeminiEvent;`
    10. Connect: `await _client.ConnectAsync();`
    11. Initialize PacketAssembler and AudioPlayback (same as before)
    12. Initialize Chirp TTS if backend is ChirpTTS -- use `settings.ApiKey` instead of Firebase API key
    13. Do NOT call SetState(Connected) here -- it happens in HandleGeminiEvent when GeminiEventType.Connected arrives (setupComplete acknowledged)
    14. Catch Exception: SetState(Error), OnError?.Invoke(ex), Debug.LogError

    **Add Update() method:**
    ```csharp
    private void Update()
    {
        _client?.ProcessEvents();
    }
    ```
    This is the fundamental architectural change. GeminiLiveClient's ConcurrentQueue is drained on the main thread every frame. All events arrive on the main thread naturally -- NO MainThreadDispatcher wrapping needed for session event routing.

    **Disconnect() rewrite:**
    1. Guard: if Disconnected or Disconnecting, return
    2. SetState(Disconnecting)
    3. Cancel _sessionCts
    4. StopListening if listening, Stop AudioPlayback, reset _aiSpeaking
    5. Reset and null PacketAssembler
    6. Dispose ChirpTTS client if exists, clear _chirpTextBuffer
    7. If _client != null: unsubscribe `_client.OnEvent -= HandleGeminiEvent;`, call `_client.Disconnect();` (synchronous, blocks up to 2s), null _client
    8. Dispose _sessionCts, null it
    9. SetState(Disconnected)
    10. Wrap in try/catch -- on any exception, still SetState(Disconnected)
    IMPORTANT: GeminiLiveClient.Disconnect() is SYNCHRONOUS. Do NOT await anything. This method should NOT be async. Change from `async void Disconnect()` to `public void Disconnect()`.

    **OnDestroy() rewrite:**
    - Same cleanup pattern as before but using _client instead of _liveSession
    - Unsubscribe from _client.OnEvent if _client != null
    - Call `_client?.Dispose();` (which internally calls Disconnect)
    - Null _client

    **SendText() rewrite:**
    - Guard: if `_client == null || !_client.IsConnected || State != Connected`, warn and return
    - Guard: if message is null/empty, return
    - Call `_client.SendText(message);` (synchronous fire-and-forget, not async)
    - This method becomes synchronous -- change from `async void SendText(string)` to `public void SendText(string)`
    - No try/catch needed (SendText internally swallows exceptions)

    **HandleAudioCaptured() rewrite:**
    - Guard: if `_client == null || !_client.IsConnected || State != Connected`, return
    - Track user speaking state (same as before)
    - Convert float[] to byte[]: `byte[] pcmBytes = FloatToPcm16(chunk);`
    - Send: `_client.SendAudio(pcmBytes);` (synchronous fire-and-forget)
    - No async, no fire-and-forget Task

    **RegisterFunction() signature update:**
    - Change to `public void RegisterFunction(string name, FunctionHandler handler)` (2 parameters, matching FunctionRegistry.Register from Plan 01)
    - Add comment: `// TODO: Phase 10 -- add function declaration parameter back with WebSocket-native type`

    **SendGoalUpdate() rewrite:**
    - Guard: if `_client == null || !_client.IsConnected || State != Connected`, return
    - Build instruction text: `var text = SystemInstructionBuilder.BuildInstructionText(_config, _goalManager);`
    - TODO: Phase 10 will implement mid-session instruction updates via WebSocket clientContent
    - For now, log a warning: "Goal update sent but mid-session instruction updates are not yet implemented (Phase 10). Goals will take effect on next connection."
    - Change from `async void` to `private void` (no async needed)

    **SendFunctionResponseAsync() stub:**
    - Comment out the body with `// TODO: Phase 10 -- implement function response sending via WebSocket toolResponse`
    - Keep the method signature for now but make it a no-op that logs a warning
    - Change return type to void and remove async: `private void SendFunctionResponse(string name, IDictionary<string, object> result, string callId)`

    **Remove ReceiveLoopAsync() and ProcessResponse() entirely.**
    These are replaced by HandleGeminiEvent (Task 2).
  </action>
  <verify>
    - PersonaSession.cs contains `GeminiLiveClient _client`
    - PersonaSession.cs contains `_client?.ProcessEvents()` in Update()
    - PersonaSession.cs contains `AIEmbodimentSettings.Instance`
    - PersonaSession.cs contains `FloatToPcm16`
    - PersonaSession.cs does NOT contain `LiveSession`, `FirebaseAI`, `ModelContent`, `ReceiveLoopAsync`, `ProcessResponse`
    - `grep -c "MainThreadDispatcher" PersonaSession.cs` returns at most 1 (HandleChirpError only)
  </verify>
  <done>PersonaSession lifecycle methods (Connect, Update, Disconnect, OnDestroy, SendText, HandleAudioCaptured) fully rewritten to use GeminiLiveClient. No Firebase types remain. Audio conversion via FloatToPcm16. ProcessEvents polling in Update.</done>
</task>

<task type="auto">
  <name>Task 2: Implement HandleGeminiEvent with complete event mapping</name>
  <files>Packages/com.google.ai-embodiment/Runtime/PersonaSession.cs</files>
  <action>
    Add the `HandleGeminiEvent` method that replaces the old `ProcessResponse`. This method runs on the MAIN THREAD (called from ProcessEvents in Update), so events are invoked DIRECTLY -- no MainThreadDispatcher wrapping.

    **HandleGeminiEvent(GeminiEvent ev) -- the complete event bridge:**

    ```csharp
    private void HandleGeminiEvent(GeminiEvent ev)
    {
        switch (ev.Type)
        {
            case GeminiEventType.Connected:
                SetState(SessionState.Connected);
                break;

            case GeminiEventType.Audio:
                HandleAudioEvent(ev);
                break;

            case GeminiEventType.OutputTranscription:
                HandleOutputTranscription(ev.Text);
                break;

            case GeminiEventType.InputTranscription:
                OnInputTranscription?.Invoke(ev.Text);
                break;

            case GeminiEventType.TurnComplete:
                HandleTurnComplete();
                break;

            case GeminiEventType.Interrupted:
                HandleInterruptedEvent();
                break;

            case GeminiEventType.FunctionCall:
                HandleFunctionCallEvent(ev);
                break;

            case GeminiEventType.Disconnected:
                if (State == SessionState.Connected || State == SessionState.Connecting)
                    SetState(SessionState.Disconnected);
                break;

            case GeminiEventType.Error:
                OnError?.Invoke(new Exception(ev.Text));
                SetState(SessionState.Error);
                Debug.LogError($"PersonaSession: GeminiLiveClient error: {ev.Text}");
                break;
        }
    }
    ```

    **HandleAudioEvent(GeminiEvent ev):**
    Port the audio handling from the old ProcessResponse, but WITHOUT MainThreadDispatcher:
    - If ev.AudioData is null or empty, return
    - Track turn start: if !_turnStarted, set _turnStarted = true, call _packetAssembler?.StartTurn()
    - If voiceBackend is GeminiNative:
      - Enqueue audio to _audioPlayback?.EnqueueAudio(ev.AudioData)
      - Track _aiSpeaking: if !_aiSpeaking, set true, invoke OnAISpeakingStarted
      - Route to PacketAssembler: _packetAssembler?.AddAudio(ev.AudioData)
    - If voiceBackend is ChirpTTS: discard Gemini audio (intentional -- Chirp TTS handles playback)
    - No MainThreadDispatcher wrapping -- we're already on the main thread

    **HandleOutputTranscription(string text):**
    - If text is null/empty, return
    - Invoke OnOutputTranscription(text)
    - Invoke OnTextReceived(text) (both events fire for output transcription)
    - Track turn start: if !_turnStarted, set _turnStarted = true, call _packetAssembler?.StartTurn()
    - Route to PacketAssembler: _packetAssembler?.AddTranscription(text)
    - Chirp TTS text accumulation: if voiceBackend is ChirpTTS, append to _chirpTextBuffer

    **HandleTurnComplete() (rename the existing private method to avoid clash with the event):**
    Actually, there's a naming conflict. The old PersonaSession has no private HandleTurnComplete. The event is OnTurnComplete. So name this `HandleTurnCompleteEvent()`:
    - If _aiSpeaking: set _aiSpeaking = false, invoke OnAISpeakingStopped
    - Invoke OnTurnComplete
    - Set _turnStarted = false
    - Call _packetAssembler?.FinishTurn()
    - Chirp full-response mode: if backend is ChirpTTS and mode is FullResponse and _chirpTextBuffer has content, extract text, clear buffer, call SynthesizeAndEnqueue(fullText)

    **HandleInterruptedEvent():**
    - Clear audio buffer: _audioPlayback?.ClearBuffer()
    - If _aiSpeaking: set _aiSpeaking = false, invoke OnAISpeakingStopped
    - Invoke OnInterrupted
    - Set _turnStarted = false
    - Call _packetAssembler?.CancelTurn()
    - Clear _chirpTextBuffer

    **HandleFunctionCallEvent(GeminiEvent ev):**
    - Parse args from JSON string to dictionary: `var args = string.IsNullOrEmpty(ev.FunctionArgsJson) ? new Dictionary<string, object>() : JObject.Parse(ev.FunctionArgsJson).ToObject<Dictionary<string, object>>();`
    - Wrap in IReadOnlyDictionary: args is already Dictionary which implements IReadOnlyDictionary
    - Route to PacketAssembler: `_packetAssembler?.AddFunctionCall(ev.FunctionName, args, null);`
    - Note: GeminiEvent does not currently carry a function call ID field beyond FunctionName and FunctionArgsJson. The FunctionCall event from GeminiLiveClient does not parse the ID (Phase 10 will add this). For now, pass null as the ID.
    - Wait -- check GeminiEvent struct. It has FunctionName and FunctionArgsJson but no FunctionId. And looking at GeminiLiveClient.HandleJsonMessage, the `fc["id"]` is not captured. For Phase 8, pass null as ID. Phase 10 will add FunctionId to GeminiEvent and capture it.

    **HandleChirpError stays the same** -- it still uses MainThreadDispatcher because ChirpTTSClient.OnError may fire from UnityWebRequest internals. This is the ONLY remaining use of MainThreadDispatcher in PersonaSession.

    **HandleSyncPacket stays the same** -- no Firebase types involved.

    **SynthesizeAndEnqueue stays the same** -- no Firebase types involved.

    **DispatchFunctionCall stays the same** -- no Firebase types. But update SendFunctionResponseAsync call to match new signature (SendFunctionResponse).

    **Key principle: NO MainThreadDispatcher in the event routing path.** Events from ProcessEvents() are already on the main thread. The ONLY remaining MainThreadDispatcher.Enqueue call should be in HandleChirpError (because ChirpTTSClient.OnError could fire from UnityWebRequest on any thread).
  </action>
  <verify>
    - PersonaSession.cs contains `HandleGeminiEvent` method with switch on GeminiEventType
    - PersonaSession.cs contains handlers for all 9 GeminiEventType values (Audio, OutputTranscription, InputTranscription, TurnComplete, Interrupted, FunctionCall, Connected, Disconnected, Error)
    - `grep -c "MainThreadDispatcher" PersonaSession.cs` returns exactly 1 (HandleChirpError only)
    - PersonaSession.cs does NOT contain `ReceiveLoopAsync` or `ProcessResponse`
    - PersonaSession.cs does NOT contain `LiveSessionResponse`, `LiveSessionContent`, `LiveSessionToolCall`, `LiveSessionToolCallCancellation`
    - PersonaSession.cs contains `JObject.Parse` for function call args parsing
    - `grep -rn "Firebase" Packages/com.google.ai-embodiment/ --include="*.cs"` returns zero matches
  </verify>
  <done>HandleGeminiEvent implements complete event mapping from GeminiEventType to PersonaSession public events. Audio routing, transcription handling, turn lifecycle, function call dispatch, and Chirp TTS integration all work through the new main-thread event bridge. Zero MainThreadDispatcher in the event path (only in HandleChirpError).</done>
</task>

</tasks>

<verification>
1. `grep -rn "Firebase\|LiveSession\|ModelContent\|MiniJSON" Packages/com.google.ai-embodiment/ --include="*.cs"` returns zero matches
2. PersonaSession.cs contains: GeminiLiveClient _client, ProcessEvents in Update, HandleGeminiEvent, FloatToPcm16, AIEmbodimentSettings.Instance
3. PersonaSession.cs preserves all public events: OnTextReceived, OnTurnComplete, OnStateChanged, OnInputTranscription, OnOutputTranscription, OnInterrupted, OnAISpeakingStarted, OnAISpeakingStopped, OnUserSpeakingStarted, OnUserSpeakingStopped, OnError, OnFunctionError, OnSyncPacket
4. PersonaSession.cs preserves all public methods: Connect, Disconnect, SendText, StartListening, StopListening, RegisterFunction, AddGoal, RemoveGoal, ReprioritizeGoal, RegisterSyncDriver
5. MainThreadDispatcher appears at most once in PersonaSession.cs (HandleChirpError only)
6. HandleGeminiEvent covers all 9 GeminiEventType values
</verification>

<success_criteria>
- PersonaSession.Connect() creates GeminiLiveClient with config from AIEmbodimentSettings and transitions Connecting -> Connected on setupComplete
- All 13 public events preserved and wired to GeminiEvent types via HandleGeminiEvent
- SendText uses GeminiLiveClient.SendText (synchronous, no async)
- HandleAudioCaptured converts float[] to PCM16 bytes via FloatToPcm16 then calls SendAudio
- Update() calls ProcessEvents() for main-thread event dispatch
- Disconnect() calls GeminiLiveClient.Disconnect() synchronously
- Zero MainThreadDispatcher usage in event routing (only in HandleChirpError)
- Chirp TTS text accumulation and synthesis patterns preserved
- PacketAssembler integration preserved (turn start, audio routing, transcription routing, turn complete/cancel)
</success_criteria>

<output>
After completion, create `.planning/phases/08-personasession-migration-and-dependency-removal/08-02-SUMMARY.md`
</output>
