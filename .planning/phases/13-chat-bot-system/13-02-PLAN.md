---
phase: 13-chat-bot-system
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - Assets/AyaLiveStream/BotReaction.cs
  - Assets/AyaLiveStream/ChatBotManager.cs
autonomous: true

must_haves:
  truths:
    - "When the user speaks via push-to-talk, 1-3 bots generate dynamic responses via Gemini structured output that react to what the user said"
    - "Dynamic responses match each bot's personality and speech style"
    - "Dynamic responses are staggered with per-bot delays so they don't all appear at once"
    - "Dynamic responses trigger ONLY from user push-to-talk -- not from Aya's dialogue, not from other bots"
    - "A single batched Gemini call returns all bot reactions (not one call per bot)"
    - "Rapid push-to-talk presses are guarded -- second request waits for first to complete"
  artifacts:
    - path: "Assets/AyaLiveStream/BotReaction.cs"
      provides: "Serializable deserialization target for Gemini structured output"
      min_lines: 8
    - path: "Assets/AyaLiveStream/ChatBotManager.cs"
      provides: "Extended with dynamic response path (HandleUserSpeech, BuildDynamicPrompt, transcript accumulation)"
      contains: "HandleUserSpeech"
  key_links:
    - from: "Assets/AyaLiveStream/ChatBotManager.cs"
      to: "Assets/AyaLiveStream/GeminiTextClient.cs"
      via: "GenerateAsync<BotReaction[]> call in HandleUserSpeech"
      pattern: "_textClient\\.GenerateAsync<BotReaction\\[\\]>"
    - from: "Assets/AyaLiveStream/ChatBotManager.cs"
      to: "PersonaSession events"
      via: "OnInputTranscription for transcript accumulation, OnUserSpeakingStopped for trigger"
      pattern: "OnUserSpeakingStopped"
    - from: "Assets/AyaLiveStream/ChatBotManager.cs"
      to: "Assets/AyaLiveStream/BotReaction.cs"
      via: "Deserialization target for Gemini response"
      pattern: "BotReaction"
---

<objective>
Add dynamic Gemini REST responses to ChatBotManager, triggered by user push-to-talk speech.

Purpose: When the user speaks, bots should react naturally to what was said -- not just post scripted lines. A single batched Gemini structured output call returns 1-3 bot reactions with personality-matched messages and staggered timing, creating the feeling that real chat viewers are responding to the user.

Output: BotReaction.cs (deserialization target), extended ChatBotManager.cs (GeminiTextClient integration, transcript accumulation, dynamic response handler, prompt builder).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-chat-bot-system/13-RESEARCH.md
@.planning/phases/13-chat-bot-system/13-01-SUMMARY.md

@Assets/AyaLiveStream/ChatBotManager.cs
@Assets/AyaLiveStream/GeminiTextClient.cs
@Assets/AyaLiveStream/ChatBotConfig.cs
@Assets/AyaLiveStream/ChatMessage.cs
@Assets/AyaLiveStream/TrackedChatMessage.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BotReaction deserialization class</name>
  <files>Assets/AyaLiveStream/BotReaction.cs</files>
  <action>
Create BotReaction.cs in the AIEmbodiment.Samples namespace. This is the deserialization target for Gemini structured output when generating dynamic bot responses.

```csharp
using System;

namespace AIEmbodiment.Samples
{
    [Serializable]
    public class BotReaction
    {
        public string botName;
        public string message;
        public float delay;
    }
}
```

Must be `[Serializable]` for Newtonsoft.Json deserialization via `JsonConvert.DeserializeObject<BotReaction[]>()` inside GeminiTextClient.GenerateAsync. Fields are lowercase to match the Gemini responseSchema property names (botName, message, delay).
  </action>
  <verify>File exists with [Serializable] attribute and three public fields: botName (string), message (string), delay (float).</verify>
  <done>BotReaction.cs exists as a serializable deserialization target for Gemini structured output with botName, message, and delay fields.</done>
</task>

<task type="auto">
  <name>Task 2: Extend ChatBotManager with dynamic Gemini response path</name>
  <files>Assets/AyaLiveStream/ChatBotManager.cs</files>
  <action>
Read the existing ChatBotManager.cs (created in Plan 01) and extend it with the dynamic response system. Add these additions WITHOUT modifying the existing scripted burst loop:

**New SerializeField:**
- `PersonaSession _session` -- for subscribing to user speech events (import AIEmbodiment namespace for this type)

**New private state:**
- `GeminiTextClient _textClient` -- created in StartBursts() or a new Initialize() method
- `string _accumulatedTranscript = ""` -- accumulates streaming transcription during PTT
- `bool _dynamicResponseInFlight = false` -- guards against rapid PTT presses (Pitfall 6 from research)
- `string _queuedTranscript = null` -- if user speaks again while a dynamic response is in flight, queue it

**Gemini response schema (static readonly JObject):**
Define `DynamicResponseSchema` as shown in research. Use UPPERCASE type constants (STRING, NUMBER, OBJECT, ARRAY) as required by Gemini v1beta responseSchema:
```csharp
private static readonly JObject DynamicResponseSchema = new JObject
{
    ["type"] = "ARRAY",
    ["items"] = new JObject
    {
        ["type"] = "OBJECT",
        ["properties"] = new JObject
        {
            ["botName"] = new JObject { ["type"] = "STRING", ["description"] = "Exact bot name from the list provided" },
            ["message"] = new JObject { ["type"] = "STRING", ["description"] = "The bot's chat message" },
            ["delay"] = new JObject { ["type"] = "NUMBER", ["description"] = "Seconds to wait before posting (0.5-3.0)" }
        },
        ["required"] = new JArray("botName", "message", "delay")
    }
};
```

**Event wiring (in StartBursts or new method called from there):**
- Create GeminiTextClient: `_textClient = new GeminiTextClient(AIEmbodimentSettings.Instance.ApiKey)`
- Subscribe: `_session.OnInputTranscription += HandleTranscription`
- Subscribe: `_session.OnUserSpeakingStopped += HandleUserSpeakingStopped`

**Event unwiring (in StopBursts and OnDestroy):**
- Unsubscribe from both events
- Dispose `_textClient`

**HandleTranscription(string text):**
Accumulate transcript: `_accumulatedTranscript = text` (OnInputTranscription provides the full accumulated text each time, not incremental deltas, so just assign directly).

**HandleUserSpeakingStopped():**
When user releases PTT:
1. Capture `_accumulatedTranscript` and reset it to ""
2. If captured transcript is empty or whitespace, return
3. If `_dynamicResponseInFlight`, store in `_queuedTranscript` and return
4. Call `_ = HandleUserSpeechAsync(transcript)` (fire-and-forget async, but save the reference for safety)

**HandleUserSpeechAsync(string userTranscript) -- async Awaitable:**
1. Set `_dynamicResponseInFlight = true`
2. Build prompt via `BuildDynamicPrompt(userTranscript)`
3. Call `BotReaction[] reactions = await _textClient.GenerateAsync<BotReaction[]>(prompt, DynamicResponseSchema)`
4. Null-check reactions (GeminiTextClient returns default if disposed during request -- Pitfall 2)
5. If reactions is not null, iterate:
   - For each reaction, await `Awaitable.WaitForSecondsAsync(reaction.delay, destroyCancellationToken)`
   - Find matching bot via `FindBotByName(reaction.botName)` (case-insensitive, underscore-normalized -- Pitfall 4)
   - If bot found, create ChatMessage, call AddMessage, track via TrackedChatMessage
   - If bot not found, log warning and skip
6. Set `_dynamicResponseInFlight = false`
7. Check `_queuedTranscript`: if not null, capture it, set to null, and call HandleUserSpeechAsync recursively
8. Wrap in try/catch for OperationCanceledException (silently return) and general Exception (log error, reset _dynamicResponseInFlight)

**BuildDynamicPrompt(string userTranscript) -- string:**
Build the prompt exactly as specified in research. Use StringBuilder:
- System context: "You are generating chat bot reactions for a livestream."
- User's speech: the transcript
- All 6 bot personalities listed with exact botName and personality description from ChatBotConfig
- Rules: 1-3 bots, match personality, chat-length (5-30 words), stagger delays (first 0.5-1.0s, subsequent 1.0-3.0s), Ghost404 selected rarely

**FindBotByName(string name) -- ChatBotConfig:**
Case-insensitive matching with underscore/space normalization. Iterate `_bots`, compare normalized names. Return null if no match.

**Important anti-patterns to avoid:**
- Do NOT make one Gemini call per bot -- single batched call returns all reactions
- Do NOT trigger dynamic responses from Aya's dialogue or other bots -- ONLY from user PTT (CONTEXT.md decision)
- Do NOT block on the Gemini call -- it's already async Awaitable
- Do NOT forget to unsubscribe from PersonaSession events in OnDestroy (prevents memory leaks and errors after scene unload)
  </action>
  <verify>
ChatBotManager.cs now contains:
1. PersonaSession SerializeField
2. GeminiTextClient creation and disposal
3. OnInputTranscription and OnUserSpeakingStopped event subscriptions
4. HandleUserSpeechAsync with GenerateAsync<BotReaction[]> call
5. BuildDynamicPrompt including all 6 bot personalities
6. FindBotByName with case-insensitive matching
7. _dynamicResponseInFlight guard with _queuedTranscript fallback
8. DynamicResponseSchema static JObject with UPPERCASE types
9. Proper event unsubscription in OnDestroy
10. try/catch for OperationCanceledException and general Exception
  </verify>
  <done>
ChatBotManager.cs extended with:
- Dynamic response path triggered by user push-to-talk via PersonaSession events
- Single batched Gemini structured output call returning 1-3 BotReaction objects
- Prompt includes all 6 bot personalities so Gemini picks natural responders
- Case-insensitive bot name matching handles Gemini name variations
- Rapid PTT guard prevents duplicate in-flight requests (queues second transcript)
- GeminiTextClient lifecycle (create/dispose) tied to StartBursts/StopBursts
  </done>
</task>

</tasks>

<verification>
1. BotReaction.cs exists with [Serializable] and correct fields
2. ChatBotManager.cs compiles with both scripted burst loop (from Plan 01) AND dynamic response path
3. Dynamic responses trigger ONLY from OnUserSpeakingStopped, not from Aya or bots
4. Single Gemini call per user speech event (not per bot)
5. GeminiTextClient is properly created and disposed
6. PersonaSession events are subscribed and unsubscribed cleanly
7. _dynamicResponseInFlight guard prevents concurrent Gemini calls
8. DynamicResponseSchema uses UPPERCASE types (STRING, NUMBER, OBJECT, ARRAY)
</verification>

<success_criteria>
- When the user speaks via push-to-talk, 1-3 bots post dynamic responses in the chat feed that react to what the user actually said
- Each dynamic response matches the responding bot's personality and speech style
- Responses appear with staggered timing (not all at once)
- Rapid PTT presses don't cause duplicate or overlapping Gemini calls
- The scripted burst loop continues running independently alongside dynamic responses
</success_criteria>

<output>
After completion, create `.planning/phases/13-chat-bot-system/13-02-SUMMARY.md`
</output>
