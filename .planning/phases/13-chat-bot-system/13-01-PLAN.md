---
phase: 13-chat-bot-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Assets/AyaLiveStream/ChatBotManager.cs
  - Assets/AyaLiveStream/TrackedChatMessage.cs
autonomous: true

must_haves:
  truths:
    - "Multiple bot personas post scripted messages in the chat feed with randomized bot count per burst (1-4)"
    - "Messages appear with staggered delays (0.8-3.0s) producing a burst-and-lull pattern"
    - "Each bot's messages are shuffled and tracked to avoid immediate repeats"
    - "Per-bot personality is expressed through typing cadence (typingSpeed), capitalization (capsFrequency), and emoji usage (emojiFrequency)"
    - "TrackedChatMessage wraps each posted message with AyaHasResponded tracking"
  artifacts:
    - path: "Assets/AyaLiveStream/ChatBotManager.cs"
      provides: "MonoBehaviour orchestrating scripted burst loop with organic timing"
      min_lines: 120
    - path: "Assets/AyaLiveStream/TrackedChatMessage.cs"
      provides: "Tracking wrapper for ChatMessage with AyaHasResponded bool and PostedAtTime"
      min_lines: 15
  key_links:
    - from: "Assets/AyaLiveStream/ChatBotManager.cs"
      to: "Assets/AyaLiveStream/LivestreamUI.cs"
      via: "AddMessage(ChatMessage) call in burst loop"
      pattern: "_livestreamUI\\.AddMessage"
    - from: "Assets/AyaLiveStream/ChatBotManager.cs"
      to: "Assets/AyaLiveStream/ChatBotConfig.cs"
      via: "SerializeField ChatBotConfig[] _bots for message pool access"
      pattern: "ChatBotConfig\\[\\]"
    - from: "Assets/AyaLiveStream/ChatBotManager.cs"
      to: "Assets/AyaLiveStream/TrackedChatMessage.cs"
      via: "TrackMessage wraps every posted ChatMessage"
      pattern: "new TrackedChatMessage"
---

<objective>
Create ChatBotManager MonoBehaviour with the scripted burst loop and TrackedChatMessage tracking system.

Purpose: This is the core chat bot engine that creates the illusion of a small live audience by posting scripted messages with organic burst-and-lull timing. It also establishes the TrackedChatMessage system that Phase 14/16 will use to prevent Aya from acknowledging the same bot message twice.

Output: ChatBotManager.cs (scripted burst loop, Fisher-Yates shuffle, per-bot personality transforms, message deduplication) and TrackedChatMessage.cs (thin tracking wrapper).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-chat-bot-system/13-RESEARCH.md

@Assets/AyaLiveStream/ChatBotConfig.cs
@Assets/AyaLiveStream/ChatMessage.cs
@Assets/AyaLiveStream/LivestreamUI.cs
@Assets/AyaLiveStream/GeminiTextClient.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TrackedChatMessage wrapper class</name>
  <files>Assets/AyaLiveStream/TrackedChatMessage.cs</files>
  <action>
Create TrackedChatMessage.cs in the AIEmbodiment.Samples namespace. This is a thin wrapper around ChatMessage for BOT-06 tracking:

```csharp
public class TrackedChatMessage
{
    public ChatMessage Message { get; }
    public bool AyaHasResponded { get; set; }
    public float PostedAtTime { get; }

    public TrackedChatMessage(ChatMessage message)
    {
        Message = message;
        AyaHasResponded = false;
        PostedAtTime = Time.time;
    }
}
```

Plain C# class (not MonoBehaviour). Import UnityEngine for Time.time. Keep it minimal -- downstream phases (14/16) will consume this through ChatBotManager's query API.
  </action>
  <verify>File exists, compiles (no syntax errors in the C# structure), follows the ChatMessage pattern of being a plain data class in the AIEmbodiment.Samples namespace.</verify>
  <done>TrackedChatMessage.cs exists with Message, AyaHasResponded, PostedAtTime properties and a constructor accepting ChatMessage.</done>
</task>

<task type="auto">
  <name>Task 2: Create ChatBotManager with scripted burst loop and personality transforms</name>
  <files>Assets/AyaLiveStream/ChatBotManager.cs</files>
  <action>
Create ChatBotManager.cs as a MonoBehaviour in AIEmbodiment.Samples namespace. This is the central chat bot orchestrator. Use `async Awaitable` (NOT coroutines) matching the GeminiTextClient pattern.

**SerializeField references:**
- `LivestreamUI _livestreamUI` -- for posting messages via AddMessage()
- `ChatBotConfig[] _bots` -- array of bot configs (6 bots, assigned in Inspector)
- Burst timing fields (all serialized for Inspector tuning):
  - `float _burstIntervalMin = 8f` -- minimum lull between bursts
  - `float _burstIntervalMax = 18f` -- maximum lull between bursts
  - `float _messageDelayMin = 0.8f` -- minimum delay between messages within a burst
  - `float _messageDelayMax = 3.0f` -- maximum delay between messages within a burst
  - `int _maxBotsPerBurst = 4` -- max bots selected per burst

**Private state:**
- `List<TrackedChatMessage> _trackedMessages` -- all posted messages with tracking
- `Dictionary<ChatBotConfig, List<int>> _usedMessageIndices` -- per-bot used index tracking to avoid repeats
- `bool _running` -- controls the burst loop
- `CancellationTokenSource _cts` -- not needed since we use destroyCancellationToken

**Lifecycle:**
- `StartBursts()` public method (called by scene controller when session goes live) sets `_running = true` and calls `ScriptedBurstLoop()` as fire-and-forget async
- `StopBursts()` public method sets `_running = false`
- `OnDestroy()` sets `_running = false`

**ScriptedBurstLoop() -- async Awaitable:**
Translate the nevatars ChatBurstController pattern to async Awaitable:
1. While `_running`:
   a. Wait random lull: `await Awaitable.WaitForSecondsAsync(Random.Range(_burstIntervalMin, _burstIntervalMax), destroyCancellationToken)`
   b. If `!_running`, break
   c. Select 1 to min(_maxBotsPerBurst, _bots.Length) bots: `int botCount = Random.Range(1, Mathf.Min(_maxBotsPerBurst, _bots.Length) + 1)`
   d. Fisher-Yates shuffle a copy of `_bots`, take first `botCount`
   e. For each selected bot:
      - Pick a message via `PickMessage(bot)` (see below)
      - Apply personality transform via `ApplyPersonality(bot, message)` (see below)
      - Create `new ChatMessage(bot, transformedMessage)`
      - Call `_livestreamUI.AddMessage(chatMsg)`
      - Track: `_trackedMessages.Add(new TrackedChatMessage(chatMsg))`
      - Wait staggered delay: `await Awaitable.WaitForSecondsAsync(Random.Range(_messageDelayMin, _messageDelayMax), destroyCancellationToken)`
2. Wrap the entire loop in try/catch for OperationCanceledException (Unity cancels on destroy) -- just silently return.

**PickMessage(ChatBotConfig bot) -- string:**
Combines scriptedMessages and messageAlternatives into a single pool. Tracks used indices per bot in `_usedMessageIndices`. When all messages are used, resets the tracking (full cycle before repeats). Uses Random.Range to pick from unused indices.

**ApplyPersonality(ChatBotConfig bot, string message) -- string:**
Applies per-bot personality transforms based on ChatBotConfig behavior fields:
- `capsFrequency`: Random.value < capsFrequency -> convert message to UPPERCASE
- `emojiFrequency`: Random.value < emojiFrequency -> append a random emoji from a small set (fire, heart, star, sparkles, etc.)
- `typingSpeed` is stored for downstream use (Phase 14 may use it for typing indicator timing) but does NOT affect the message text itself

**ShuffleCopy<T>(T[] array) -- T[]:**
Fisher-Yates shuffle on a copy (do NOT mutate the original array). Return the shuffled copy. Translate directly from nevatars ChatBurstController.ShuffleList but operating on arrays:
```csharp
private T[] ShuffleCopy<T>(T[] source)
{
    T[] copy = (T[])source.Clone();
    for (int i = copy.Length - 1; i > 0; i--)
    {
        int j = Random.Range(0, i + 1);
        (copy[i], copy[j]) = (copy[j], copy[i]);
    }
    return copy;
}
```

**Public query API for downstream phases (Phase 14/16):**
- `IReadOnlyList<TrackedChatMessage> GetUnrespondedMessages()` -- returns tracked messages where `AyaHasResponded == false`
- `IReadOnlyList<TrackedChatMessage> AllTrackedMessages` -- read-only access to all tracked messages

**Important anti-patterns to avoid:**
- Do NOT use coroutines (IEnumerator) -- use async Awaitable throughout
- Do NOT modify ChatBotConfig.scriptedMessages at runtime -- track used indices separately
- Do NOT create a GeminiTextClient here -- that belongs in Plan 02 (dynamic responses)
- Do NOT subscribe to PersonaSession events here -- that belongs in Plan 02
- Use `destroyCancellationToken` on all WaitForSecondsAsync calls to handle MonoBehaviour destruction gracefully
  </action>
  <verify>
File exists and contains:
1. ChatBotManager class inheriting MonoBehaviour
2. ScriptedBurstLoop method using async Awaitable (not IEnumerator)
3. Fisher-Yates ShuffleCopy method
4. PickMessage with per-bot used-index tracking
5. ApplyPersonality with capsFrequency and emojiFrequency transforms
6. GetUnrespondedMessages() public query method
7. try/catch for OperationCanceledException around the burst loop
8. All SerializeField timing parameters with the specified defaults
  </verify>
  <done>
ChatBotManager.cs exists with:
- Scripted burst loop posting 1-4 bot messages per burst with 0.8-3.0s staggered delays and 8-18s lull periods
- Fisher-Yates shuffle for bot selection and message order
- Per-bot message picking with used-index deduplication (full cycle before repeats)
- Per-bot personality transforms (caps, emoji) based on ChatBotConfig behavior fields
- TrackedChatMessage tracking for every posted message
- GetUnrespondedMessages() query API for Phase 14/16 consumption
- Graceful cancellation via destroyCancellationToken
  </done>
</task>

</tasks>

<verification>
1. Both files exist in Assets/AyaLiveStream/
2. Both files use namespace AIEmbodiment.Samples
3. ChatBotManager references LivestreamUI.AddMessage, ChatBotConfig, ChatMessage, TrackedChatMessage
4. No coroutines (IEnumerator) -- all async Awaitable
5. No GeminiTextClient usage (reserved for Plan 02)
6. No PersonaSession event subscriptions (reserved for Plan 02)
7. Fisher-Yates shuffle matches nevatars ChatBurstController algorithm
8. destroyCancellationToken used on all Awaitable.WaitForSecondsAsync calls
</verification>

<success_criteria>
- ChatBotManager can be added to a GameObject, assigned 6 ChatBotConfig references and a LivestreamUI reference, and when StartBursts() is called, scripted messages appear in the chat feed with organic burst-and-lull timing
- Each burst selects 1-4 random bots, picks non-repeating messages from their combined scriptedMessages + messageAlternatives pool, and applies personality transforms
- TrackedChatMessage system tracks every posted message with AyaHasResponded flag for downstream consumption
</success_criteria>

<output>
After completion, create `.planning/phases/13-chat-bot-system/13-01-SUMMARY.md`
</output>
